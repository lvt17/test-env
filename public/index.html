<!DOCTYPE html>
<!-- Version: 2.0.0-cache-bust-20251218232800 -->
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <title>QU·∫¢N L√ù V·∫¨N ƒê∆†N LumiGlobal</title>
  <!-- Preload API data for faster initial load -->
  <link rel="preload" href="/sync/db-data?page=1&limit=40&sortBy=id&order=asc" as="fetch" crossorigin="anonymous">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

    :root {
      --font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      --primary-color: #1D2F5F;
      --primary-color-dark: #16254A;
      --primary-color-light: #E8EAF6;
      --accent-color: #F37021;
      --accent-color-dark: #D85B0A;
      --success-color: #28a745;
      --warning-color: #ffc107;
      --danger-color: #dc3545;
      --text-color: #212529;
      --text-color-muted: #6c757d;
      --bg-body: #f8f9fa;
      --bg-card: #ffffff;
      --border-color: #dee2e6;
      --border-radius: 6px;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --transition-speed: 0.2s;
    }

    html {
      font-size: 16px;
    }

    body {
      font-family: var(--font-family);
      padding: 20px;
      background-color: var(--bg-body);
      color: var(--text-color);
      margin: 0;
      line-height: 1.5;
    }

    .page-header {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 16px;
      margin-bottom: 2rem;
    }

    .header-logo {
      height: 50px;
      width: auto;
      mix-blend-mode: darken;
    }

    h2 {
      margin: 0;
      color: var(--accent-color);
      font-weight: 700;
      text-transform: uppercase;
      font-size: 1.75rem;
    }

    #loader-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      transition: opacity 0.3s ease;
    }

    #loader-overlay img {
      max-width: 200px;
      animation: pulse 1.5s infinite ease-in-out;
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 1;
      }

      50% {
        transform: scale(1.05);
        opacity: 0.8;
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    @keyframes pulse-glow {
      0% {
        box-shadow: 0 0 5px rgba(243, 112, 33, 0.5);
      }

      50% {
        box-shadow: 0 0 15px rgba(243, 112, 33, 0.8), 0 0 25px rgba(243, 112, 33, 0.3);
      }

      100% {
        box-shadow: 0 0 5px rgba(243, 112, 33, 0.5);
      }
    }

    .controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--bg-card);
      padding: 1rem 1.5rem;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-md);
      /* Removed sticky positioning */
      flex-wrap: wrap;
      gap: 1rem;
      border: 1px solid var(--border-color);
      margin-bottom: 1.5rem;
    }

    .controls .left-controls,
    .controls .right-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    button,
    .btn {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: var(--border-radius);
      font-size: 0.9rem;
      font-weight: 500;
      color: white;
      transition: all var(--transition-speed) ease-in-out;
      cursor: pointer;
      box-shadow: var(--shadow-sm);
    }

    button:hover,
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    button:focus-visible,
    .btn:focus-visible {
      outline: 2px solid var(--primary-color);
      outline-offset: 2px;
    }

    .refresh-btn {
      background-color: var(--success-color);
    }

    .update-btn {
      background-color: var(--primary-color);
    }

    .clear-filter-btn {
      background-color: var(--warning-color);
      color: var(--text-color);
    }

    .refresh-btn:hover {
      background-color: #218838;
    }

    .update-btn:hover {
      background-color: var(--primary-color-dark);
    }

    .clear-filter-btn:hover {
      background-color: #e0a800;
    }

    input[type="text"],
    input[type="date"],
    input[type="number"],
    select,
    .filter-select {
      padding: 0.5rem 0.75rem;
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      font-size: 0.9rem;
      background-color: var(--bg-card);
      transition: border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
    }

    input:focus,
    select:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(29, 47, 95, 0.25);
    }

    .tab-controls {
      display: flex;
      border-bottom: 2px solid var(--border-color);
      margin-bottom: 1.5rem;
      margin-left: 0;
      padding: 0;
      border-radius: 0;
      overflow: visible;
    }

    .tab-btn {
      background-color: transparent;
      border: none;
      border-bottom: 3px solid transparent;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-color-muted);
      border-radius: 0;
      margin-bottom: -2px;
      box-shadow: none;
    }

    .tab-btn:hover {
      color: var(--accent-color);
      background-color: #fef0e8;
      transform: none;
      box-shadow: none;
    }

    .tab-btn.active {
      color: var(--accent-color);
      background-color: transparent;
      border-color: var(--accent-color);
      box-shadow: none;
    }

    .content-tab {
      display: none;
    }

    .content-tab.active {
      display: block;
    }

    .main-table-wrapper {
      overflow: auto;
      max-height: calc(100vh - 250px);
      background: var(--bg-card);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-md);
      border: 1px solid var(--border-color);
    }

    table {
      border-collapse: collapse;
      width: 100%;
      min-width: 2200px;
      font-size: 0.8rem;
      font-weight: 500;
    }

    th,
    td {
      border: none;
      border-bottom: 1px solid var(--border-color);
      padding: 0.75rem 1rem;
      white-space: nowrap;
      background-color: var(--bg-card);
      text-align: left;
    }

    th {
      background-color: #f8f9fa;
      color: var(--text-color);
      font-weight: 600;
      vertical-align: top;
      position: sticky;
      top: 0;
      z-index: 20;
      border-bottom-width: 2px;
    }

    #tableBody tr:hover td,
    #japanTableBody tr:hover td,
    #leaderTableBody tr:hover td,
    #mentionedTableBody tr:hover td,
    #hcmTableBody tr:hover td,
    #hanoiTableBody tr:hover td {
      /* Th√™m ID m·ªõi */
      background-color: var(--primary-color-light) !important;
      cursor: pointer;
    }

    th .filter-input,
    th .filter-select {
      width: 100%;
      box-sizing: border-box;
      margin-top: 0.5rem;
      padding: 0.3rem 0.5rem;
      font-size: 0.75rem;
    }

    th .tracking-filter-container {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 0.5rem;
    }

    th .tracking-filter-container input {
      width: 100%;
      box-sizing: border-box;
    }

    .multi-select-container {
      position: relative;
      display: inline-block;
      width: 100%;
      margin-top: 0.5rem;
    }

    .multi-select-container .multi-select-button {
      background-color: var(--bg-card);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      font-size: 0.75rem;
      padding: 0.3rem 0.5rem;
      text-align: left;
      width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      border-radius: var(--border-radius);
      cursor: pointer;
    }

    .multi-select-container .multi-select-button:hover {
      border-color: var(--secondary-color);
    }

    .checkbox-dropdown {
      display: none;
      position: fixed;
      background-color: var(--bg-card);
      min-width: 220px;
      box-shadow: var(--shadow-lg);
      z-index: 99999;
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      max-height: 250px;
      overflow-y: auto;
      padding: 0.5rem;
    }

    .checkbox-dropdown.show {
      display: block;
    }

    .checkbox-dropdown label {
      display: flex;
      align-items: center;
      padding: 0.4rem 0.6rem;
      cursor: pointer;
      border-radius: 4px;
      transition: background-color var(--transition-speed);
      white-space: nowrap;
      font-size: 0.8rem;
      color: var(--text-color);
      font-weight: 400;
    }

    .checkbox-dropdown label:hover {
      background-color: #e9ecef;
    }

    .checkbox-dropdown label input {
      margin-right: 0.5rem;
    }

    .controls .checkbox-dropdown {
      font-size: 1rem;
    }

    .controls .checkbox-dropdown label {
      font-size: 0.9rem;
    }

    .fixed-column {
      position: sticky;
      z-index: 5;
    }

    th.fixed-column {
      z-index: 30;
      background-color: #f1f3f5;
    }

    td.fixed-column {
      background-color: #f8f9fa;
      border-right: 1px solid var(--border-color);
    }

    td.editable {
      background-color: #e8f5e9;
      border-left: 3px solid #66bb6a;
    }

    .summary-info {
      background: var(--primary-color-light);
      padding: 0.5rem 1rem;
      border-radius: var(--border-radius);
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--primary-color-dark);
      border: 1px solid #c9d1e9;
    }

    /* Minimalist Pagination */
    .pagination-minimal {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px 12px;
      background: #fff;
      border-radius: 20px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      font-size: 13px;
    }

    .pg-btn {
      width: 28px;
      height: 28px;
      border: none;
      background: #f5f5f5;
      border-radius: 50%;
      cursor: pointer;
      font-size: 14px;
      color: #555;
      transition: all 0.2s;
    }

    .pg-btn:hover:not(:disabled) {
      background: var(--primary-color);
      color: #fff;
    }

    .pg-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .pg-info {
      font-weight: 600;
      color: #333;
      padding: 0 8px;
      min-width: 60px;
      text-align: center;
    }

    .pg-total {
      color: #888;
      font-size: 12px;
      margin-left: 8px;
      padding-left: 8px;
      border-left: 1px solid #ddd;
    }

    .pg-divider {
      width: 1px;
      height: 16px;
      background: #ddd;
      margin: 0 8px;
    }

    .pg-stat {
      font-size: 13px;
      color: #555;
    }

    .pg-stat b {
      color: #333;
      font-weight: 600;
    }

    .pg-amount {
      margin-left: 12px;
      padding-left: 12px;
      border-left: 1px solid #ddd;
    }

    .pg-amount b {
      color: #4CAF50;
    }

    .cell-selected {
      background-color: #a7ffeb !important;
      outline: 2px solid #00bfa5;
      outline-offset: -2px;
    }

    .cell-ok {
      background-color: #d4edda !important;
    }

    .cell-cancel {
      background-color: #f8d7da !important;
    }

    .cell-xl {
      background-color: #fff3cd !important;
    }

    ::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }

    ::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    ::-webkit-scrollbar-thumb {
      background-color: var(--primary-color);
      border-radius: 10px;
      border: 3px solid #f1f1f1;
    }

    ::-webkit-scrollbar-thumb:hover {
      background-color: var(--primary-color-dark);
    }

    .controls .multi-select-container button {
      background-color: white;
      color: #333;
      border: 1px solid #ccc;
      font-size: 0.9rem;
      padding: 0.5rem 0.75rem;
      text-align: left;
      width: 250px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .controls .checkbox-dropdown {
      min-width: 250px;
      max-height: 300px;
      padding: 10px;
    }

    .controls .checkbox-dropdown label {
      padding: 8px 12px;
      font-size: 16px;
      font-weight: normal;
      color: #333;
    }

    .controls .checkbox-dropdown label input {
      margin-right: 10px;
    }

    .status {
      font-size: 0.85em;
      margin-left: 8px;
      color: var(--success-color);
    }

    .error-status {
      color: var(--danger-color);
    }

    td.highlight {
      background-color: #ffeb3b !important;
    }

    /* === NEW POPOVER STYLES === */
    .popover-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    }

    .popover-content {
      background: white;
      padding: 20px;
      border-radius: var(--border-radius);
      width: 90%;
      max-width: 600px;
      box-shadow: var(--shadow-lg);
      display: flex;
      flex-direction: column;
    }

    .popover-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 10px;
      margin-bottom: 15px;
    }

    .popover-header h3 {
      margin: 0;
      color: var(--primary-color);
    }

    .close-popover {
      background: transparent;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-color-muted);
    }

    .popover-body {
      max-height: 400px;
      overflow-y: auto;
      margin-bottom: 20px;
    }

    .popover-footer {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      border-top: 1px solid var(--border-color);
      padding-top: 15px;
    }

    .pending-change-item {
      padding: 8px;
      border-bottom: 1px solid #eee;
      font-size: 0.9rem;
    }

    .pending-change-item:last-child {
      border-bottom: none;
    }

    .pending-change-item strong {
      color: var(--primary-color-dark);
    }

    .pending-change-item ul {
      margin-top: 5px;
      padding-left: 20px;
    }

    /* Badge for status button */
    #pending-count-badge {
      background-color: white;
      color: var(--accent-color);
      border-radius: 50%;
      padding: 2px 6px;
      font-size: 0.75em;
      font-weight: bold;
      vertical-align: top;
      margin-left: 5px;
      min-width: 18px;
      text-align: center;
      border: 2px solid var(--accent-color);
    }

    #update-info {
      font-size: 0.85em;
      font-weight: 500;
      margin-left: 5px;
    }

    #pending-count-text {
      font-weight: bold;
      color: inherit;
    }

    /* D√°n ƒëo·∫°n CSS n√†y v√†o cu·ªëi th·∫ª <style> c·ªßa b·∫°n */

    td.long-text-cell {
      max-width: 250px;
      /* Chi·ªÅu r·ªông m·∫∑c ƒë·ªãnh cho c·ªôt */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      vertical-align: top;
      /* CƒÉn n·ªôi dung l√™n tr√™n ƒë·ªÉ d·ªÖ nh√¨n h∆°n */
      cursor: pointer;
    }

    td.long-text-cell.expanded {
      white-space: pre-wrap;
      /* Cho ph√©p xu·ªëng d√≤ng v√† bao b·ªçc vƒÉn b·∫£n */
      text-overflow: clip;
      overflow: visible;
      position: relative;
      z-index: 10;
      /* ƒê·∫£m b·∫£o n·ªôi dung m·ªü r·ªông kh√¥ng b·ªã che */
      background-color: #feffde !important;
      /* ƒê·ªïi m√†u n·ªÅn ƒë·ªÉ l√†m n·ªïi b·∫≠t √¥ ƒëang m·ªü r·ªông */
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      /* Th√™m b√≥ng ƒë·ªï nh·∫π */
    }
  </style>
</head>

<body>

  <div id="loader-overlay">
    <img
      src="https://www.appsheet.com/template/gettablefileurl?appName=Appsheet-325045268&tableName=Kho%20%E1%BA%A3nh&fileName=Kho%20%E1%BA%A3nh_Images%2Ff930e667.%E1%BA%A2nh.025539.jpg"
      alt="Loading Logo">
  </div>

  <div class="page-header">
    <img class="header-logo"
      src="https://www.appsheet.com/template/gettablefileurl?appName=Appsheet-325045268&tableName=Kho%20%E1%BA%A3nh&fileName=Kho%20%E1%BA%A3nh_Images%2Ff930e667.%E1%BA%A2nh.025539.jpg"
      alt="LumiGlobal Logo">
    <h2>QU·∫¢N L√ù V·∫¨N ƒê∆†N LumiGlobal</h2>
  </div>

  <div class="tab-controls">
    <button id="tabData" class="tab-btn active">D·ªØ li·ªáu ƒë∆°n h√†ng</button>
    <button id="tabLeader" class="tab-btn" style="display: none;">ƒê∆°n c·ªßa Leader</button>
    <button id="tabJapan" class="tab-btn">ƒê∆°n Nh·∫≠t</button>
    <button id="tabMentioned" class="tab-btn" style="display: none;">Ng∆∞·ªùi ƒë∆∞·ª£c nh·∫Øc h·ªô</button>
    <!-- NEW TABS -->
    <button id="tabHCM" class="tab-btn" style="display: none;">FFM ƒë·∫©y v·∫≠n h√†nh</button>
    <button id="tabHanoi" class="tab-btn" style="display: none;">FFM H√† N·ªôi</button>
  </div>

  <div id="contentData" class="content-tab active">
    <div class="controls">
      <div class="left-controls">
        <span id="userInfo"></span>
        <button id="refreshData" class="refresh-btn"><span class="refresh-icon">‚Üª</span> Load</button>
        <button id="updateAll" class="update-btn">C·∫≠p nh·∫≠t</button>
        <!-- NEW STATUS BUTTON -->
        <button id="statusButton" class="status-btn" style="background-color: #6c757d;">
          Tr·∫°ng th√°i c·∫≠p nh·∫≠t
          <span id="update-info">
            (<span id="pending-count-text">0</span> b·∫£n c·∫≠p nh·∫≠t)
          </span>
          <span id="pending-count-badge">0</span>
        </button>
        <div class="fixed-col-control">
          <span>C·ªôt c·ªë ƒë·ªãnh:</span>
          <input type="number" id="fixedColumnCountInput" value="1" min="0" style="width: 70px;">
        </div>
        <div id="summaryInfo" class="summary-info" style="display:none;"></div>
        <div id="paginationInfo" class="pagination-minimal"></div>
        <div id="selectionSummary" class="summary-info" style="background-color: #e8f5e9; border: 1px solid #a5d6a7;">
        </div>
      </div>
      <div class="right-controls">
        <div class="date-filter">
          <span>T·ª´:</span><input type="date" id="startDateFilter" />
          <span>ƒê·∫øn:</span><input type="date" id="endDateFilter" />
        </div>
        <select id="productFilter" class="filter-select">
          <option value="">T·∫•t c·∫£ s·∫£n ph·∫©m</option>
        </select>
        <select id="marketFilter" class="filter-select">
          <option value="">T·∫•t c·∫£ khu v·ª±c</option>
        </select>
        <button id="clearFilters" class="clear-filter-btn">X√≥a l·ªçc</button>
      </div>
    </div>
    <div class="main-table-wrapper" id="tableContainer">
      <table>
        <thead id="tableHead"></thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </div>

  <!-- N·ªòI DUNG TAB LEADER -->
  <div id="contentLeader" class="content-tab">
    <div class="controls">
      <div class="left-controls">
        <span class="tab-info-text">ƒê∆°n h√†ng do b·∫°n x·ª≠ l√Ω</span>
        <button id="leaderRefreshData" class="refresh-btn"><span class="refresh-icon">‚Üª</span> Load</button>
        <button id="leaderUpdateAll" class="update-btn">C·∫≠p nh·∫≠t</button>
        <div id="leaderSummaryInfo" class="summary-info"></div>
      </div>
      <div class="right-controls">
        <div class="date-filter">
          <span>T·ª´:</span><input type="date" id="leaderStartDateFilter" />
          <span>ƒê·∫øn:</span><input type="date" id="leaderEndDateFilter" />
        </div>
        <select id="leaderProductFilter" class="filter-select">
          <option value="">S·∫£n ph·∫©m</option>
        </select>
        <button id="leaderClearFilters" class="clear-filter-btn">X√≥a l·ªçc</button>
      </div>
    </div>
    <div class="main-table-wrapper" id="leaderTableContainer">
      <table>
        <thead id="leaderTableHead"></thead>
        <tbody id="leaderTableBody"></tbody>
      </table>
    </div>
  </div>

  <div id="contentJapan" class="content-tab">
    <div class="controls">
      <div class="left-controls">
        <span class="tab-info-text">ƒê∆°n h√†ng khu v·ª±c: Nh·∫≠t B·∫£n</span>
        <button id="japanRefreshData" class="refresh-btn"><span class="refresh-icon">‚Üª</span> Load</button>
        <button id="japanUpdateAll" class="update-btn">C·∫≠p nh·∫≠t</button>
        <div id="japanSummaryInfo" class="summary-info"></div>
      </div>
      <div class="right-controls">
        <div class="date-filter">
          <span>T·ª´:</span><input type="date" id="japanStartDateFilter" />
          <span>ƒê·∫øn:</span><input type="date" id="japanEndDateFilter" />
        </div>
        <select id="japanProductFilter" class="filter-select">
          <option value="">S·∫£n ph·∫©m</option>
        </select>
        <select id="japanStaffFilter" class="filter-select">
          <option value="">NV V·∫≠n ƒë∆°n</option>
        </select>
        <button id="japanClearFilters" class="clear-filter-btn">X√≥a l·ªçc</button>
      </div>
    </div>
    <div class="main-table-wrapper" id="japanTableContainer">
      <table>
        <thead id="japanTableHead"></thead>
        <tbody id="japanTableBody"></tbody>
      </table>
    </div>
  </div>

  <!-- N·ªòI DUNG TAB NG∆Ø·ªúI ƒê∆Ø·ª¢C NH·∫ÆC H·ªò M·ªöI -->
  <div id="contentMentioned" class="content-tab">
    <div class="controls">
      <div class="left-controls">
        <span class="tab-info-text">ƒê∆°n h√†ng c·ªßa ng∆∞·ªùi ƒë∆∞·ª£c nh·∫Øc h·ªô</span>
        <button id="mentionedRefreshData" class="refresh-btn"><span class="refresh-icon">‚Üª</span> Load</button>
        <button id="mentionedUpdateAll" class="update-btn">C·∫≠p nh·∫≠t</button>
        <div id="mentionedSummaryInfo" class="summary-info"></div>
      </div>
      <div class="right-controls">
        <div class="date-filter">
          <span>T·ª´:</span><input type="date" id="mentionedStartDateFilter" />
          <span>ƒê·∫øn:</span><input type="date" id="mentionedEndDateFilter" />
        </div>
        <select id="mentionedProductFilter" class="filter-select">
          <option value="">S·∫£n ph·∫©m</option>
        </select>
        <button id="mentionedClearFilters" class="clear-filter-btn">X√≥a l·ªçc</button>
      </div>
    </div>
    <div class="main-table-wrapper" id="mentionedTableContainer">
      <table>
        <thead id="mentionedTableHead"></thead>
        <tbody id="mentionedTableBody"></tbody>
      </table>
    </div>
  </div>

  <!-- N·ªòI DUNG TAB HCM -->
  <div id="contentHCM" class="content-tab">
    <div class="controls">
      <div class="left-controls">
        <span class="tab-info-text">ƒê∆°n h√†ng khu v·ª±c: H·ªì Ch√≠ Minh</span>
        <button id="hcmRefreshData" class="refresh-btn"><span class="refresh-icon">‚Üª</span> Load</button>
        <button id="hcmUpdateAll" class="update-btn">C·∫≠p nh·∫≠t</button>
        <div id="hcmSummaryInfo" class="summary-info"></div>
      </div>
      <div class="right-controls">
        <div class="date-filter">
          <span>T·ª´:</span><input type="date" id="hcmStartDateFilter" />
          <span>ƒê·∫øn:</span><input type="date" id="hcmEndDateFilter" />
        </div>
        <select id="hcmProductFilter" class="filter-select">
          <option value="">S·∫£n ph·∫©m</option>
        </select>
        <select id="hcmStaffFilter" class="filter-select">
          <option value="">NV V·∫≠n ƒë∆°n</option>
        </select>
        <button id="hcmClearFilters" class="clear-filter-btn">X√≥a l·ªçc</button>
      </div>
    </div>
    <div class="main-table-wrapper" id="hcmTableContainer">
      <table>
        <thead id="hcmTableHead"></thead>
        <tbody id="hcmTableBody"></tbody>
      </table>
    </div>
  </div>

  <!-- N·ªòI DUNG TAB H√Ä N·ªòI -->
  <div id="contentHanoi" class="content-tab">
    <div class="controls">
      <div class="left-controls">
        <span class="tab-info-text">ƒê∆°n h√†ng khu v·ª±c: H√† N·ªôi</span>
        <button id="hanoiRefreshData" class="refresh-btn"><span class="refresh-icon">‚Üª</span> Load</button>
        <button id="hanoiUpdateAll" class="update-btn">C·∫≠p nh·∫≠t</button>
        <div id="hanoiSummaryInfo" class="summary-info"></div>
      </div>
      <div class="right-controls">
        <div class="date-filter">
          <span>T·ª´:</span><input type="date" id="hanoiStartDateFilter" />
          <span>ƒê·∫øn:</span><input type="date" id="hanoiEndDateFilter" />
        </div>
        <select id="hanoiMarketFilter" class="filter-select">
          <option value="">T·∫•t c·∫£ khu v·ª±c</option>
        </select>
        <select id="hanoiProductFilter" class="filter-select">
          <option value="">S·∫£n ph·∫©m</option>
        </select>
        <select id="hanoiStaffFilter" class="filter-select">
          <option value="">NV V·∫≠n ƒë∆°n</option>
        </select>
        <button id="hanoiClearFilters" class="clear-filter-btn">X√≥a l·ªçc</button>
      </div>
    </div>
    <div class="main-table-wrapper" id="hanoiTableContainer">
      <table>
        <thead id="hanoiTableHead"></thead>
        <tbody id="hanoiTableBody"></tbody>
      </table>
    </div>
  </div>

  <!-- NEW STATUS POPOVER HTML -->
  <div id="status-popover" class="popover-overlay" style="display: none;">
    <div class="popover-content">
      <div class="popover-header">
        <h3>C√°c thay ƒë·ªïi ƒëang ch·ªù</h3>
        <button class="close-popover">&times;</button>
      </div>
      <div id="pending-changes-list" class="popover-body">
        <!-- Changes will be listed here -->
      </div>
      <div class="popover-footer">
        <button id="cancel-all-changes" class="btn clear-filter-btn">H·ªßy t·∫•t c·∫£</button>
        <button id="update-all-pending" class="btn update-btn">C·∫≠p nh·∫≠t t·∫•t c·∫£</button>
      </div>
    </div>
  </div>
  <script>
    const prod = 'https://test-env.vercel.app'; // Backend m·ªõi v·ªõi credentials m·ªõi
    const localhost = 'http://localhost:8081';
    const host = 'prod';
    const mainHost = host === 'prod' ? prod : localhost;
    const SHEET_NAME = 'F3';

    // === NEW: Database API URLs (faster reads) ===
    const DB_DATA_URL = `${mainHost}/sync/db-data`; // Read from PostgreSQL
    const DB_UPDATE_URL = `${mainHost}/sync/update`; // Write via queue (Web ‚Üí DB ‚Üí Sheet)
    const DB_STATUS_URL = `${mainHost}/sync/status`; // Check sync status

    // === Legacy Sheet API (still used for bulk updates) ===
    const UPDATE_SINGLE_URL = `${mainHost}/sheet/${SHEET_NAME}/update-single`;
    const UPDATE_BULK_URL = `${mainHost}/sync/update-bulk`;
    const SSE_URL = `${mainHost}/sse/subscribe/${SHEET_NAME}`;
    const POLL_URL = `${mainHost}/sheet/${SHEET_NAME}/poll`;
    const LOCAL_STORAGE_KEY = 'lumiglobal_pending_changes';

    // === Unicode Normalization (handles Hu·ª∑ vs H·ªßy) ===
    function normalizeUnicode(value) {
      if (typeof value !== 'string') return value;
      return value.normalize('NFC');
    }

    // === PAGINATION STATE ===
    let currentPage = 1;
    let pageSize = 40;
    let totalRecords = 0;
    let totalPages = 0;

    // === PAGE CACHE (prefetch next page) ===
    const pageCache = new Map(); // Map<pageNumber, {data, timestamp}>
    const CACHE_TTL_MS = 30000; // Cache valid for 30 seconds
    let isPrefetching = false;

    // === REAL-TIME SYNC STATE ===
    let eventSource = null;
    let sseReconnectAttempts = 0;
    const SSE_MAX_RECONNECT_ATTEMPTS = 3;
    const SSE_MAX_RECONNECT_DELAY = 30000;
    let isSyncing = false;
    let usePollingFallback = false;
    let pollIntervalId = null;
    const POLL_INTERVAL_MS = 5000; // Poll every 5 seconds
    let lastSyncTimestamp = Date.now();


    // === C·∫§U H√åNH C·ªòT ===
    const columnDisplayMapping = {};
    const editableCols = ["K·∫øt qu·∫£ Check", "Tr·∫°ng th√°i giao h√†ng NB", "L√Ω do", "Tr·∫°ng th√°i thu ti·ªÅn", "Ghi ch√∫ c·ªßa Vƒê"];
    // === TH√äM 2 D√íNG N√ÄY ===
    const longTextColumns = ["L√Ω do", "Ghi ch√∫ c·ªßa Vƒê"]; // C√°c c·ªôt c·∫ßn √°p d·ª•ng
    let areLongTextFieldsExpanded = false; // Bi·∫øn l∆∞u tr·∫°ng th√°i
    // === K·∫æT TH√öC ===
    // === H√ÄM M·ªöI ƒê·ªÇ M·ªû R·ªòNG/THU G·ªåN TO√ÄN B·ªò C·ªòT ===
    function toggleAllLongTextCells(expand) {
      const activeTableBody = document.querySelector('.content-tab.active tbody');
      if (!activeTableBody) return;

      const targetColumnIndexes = displayColumns
        .map((colName, index) => (longTextColumns.includes(colName) ? index : -1))
        .filter(index => index !== -1);

      if (targetColumnIndexes.length === 0) return;

      activeTableBody.querySelectorAll('tr').forEach(row => {
        targetColumnIndexes.forEach(colIndex => {
          const cell = row.cells[colIndex];
          if (cell) {
            if (expand) {
              cell.classList.add('expanded');
            } else {
              cell.classList.remove('expanded');
            }
          }
        });
      });

      const activeTab = document.querySelector('.content-tab.active');
      if (activeTab) {
        const activeConfig = allTabConfigs.find(c => c.table.body === activeTab.querySelector('tbody')?.id);
        if (activeConfig) {
          setTimeout(() => updateStickyColumns(activeConfig), 50);
        }
      }
    }
    const dropdownCols = {
      "K·∫øt qu·∫£ Check": ["", "OK", "Hu·ª∑", "Treo", "V·∫≠n ƒë∆°n XL", "ƒê·ª£i h√†ng", "Kh√°ch h·∫πn"],
      "Tr·∫°ng th√°i giao h√†ng NB": ["", "Giao Th√†nh C√¥ng", "ƒêang Giao", "Ch∆∞a Giao", "Hu·ª∑", "Ho√†n", "Ch·ªù Check", "Giao kh√¥ng th√†nh c√¥ng", "Bom_Th·∫•t L·∫°c"],
      "Tr·∫°ng th√°i thu ti·ªÅn": ["", "C√≥ bill", "C√≥ bill 1 ph·∫ßn", "Bom_b√πng_ch·∫∑n", "H·∫πn Thanh To√°n", "Ho√†n H√†ng", "Kh√≥ ƒê√≤i", "Kh√¥ng nh·∫≠n ƒë∆∞·ª£c h√†ng", "Kh√¥ng PH d∆∞·ªõi 3N", "Thanh to√°n ph√≠ ho√†n", "KPH nhi·ªÅu ng√†y"]
    };
    const displayColumns = ["M√£ ƒë∆°n h√†ng", "K·∫øt qu·∫£ Check", "Tr·∫°ng th√°i giao h√†ng NB", "M√£ Tracking", "L√Ω do", "Tr·∫°ng th√°i thu ti·ªÅn", "Ghi ch√∫ c·ªßa Vƒê", "Ng√†y l√™n ƒë∆°n", "Name*", "Phone*", "Add", "City", "State", "khu v·ª±c", "Zipcode", "M·∫∑t h√†ng", "T√™n m·∫∑t h√†ng 1", "S·ªë l∆∞·ª£ng m·∫∑t h√†ng 1", "T√™n m·∫∑t h√†ng 2", "S·ªë l∆∞·ª£ng m·∫∑t h√†ng 2", "Qu√† t·∫∑ng", "S·ªë l∆∞·ª£ng qu√† k√®m", "Gi√° b√°n", "Lo·∫°i ti·ªÅn thanh to√°n", "T·ªïng ti·ªÅn VNƒê", "H√¨nh th·ª©c thanh to√°n", "Ghi ch√∫", "Ng√†y ƒë√≥ng h√†ng", "Tr·∫°ng th√°i giao h√†ng", "Th·ªùi gian giao d·ª± ki·∫øn", "Ph√≠ ship n·ªôi ƒë·ªãa M·ªπ (usd)", "Ph√≠ x·ª≠ l√Ω ƒë∆°n ƒë√≥ng h√†ng-L∆∞u kho(usd)", "GHI CH√ö", "Nh√¢n vi√™n Sale", "NV V·∫≠n ƒë∆°n", "ƒê∆°n v·ªã v·∫≠n chuy·ªÉn", "S·ªë ti·ªÅn c·ªßa ƒë∆°n h√†ng ƒë√£ v·ªÅ TK Cty", "K·∫ø to√°n x√°c nh·∫≠n thu ti·ªÅn v·ªÅ", "Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"];
    const allDateColumns = ["Ng√†y l√™n ƒë∆°n", "Ng√†y ƒë√≥ng h√†ng"];
    const columnsToMakeDynamic = ["K·∫øt qu·∫£ Check", "Tr·∫°ng th√°i giao h√†ng NB", "Tr·∫°ng th√°i thu ti·ªÅn", "khu v·ª±c", "M·∫∑t h√†ng", "Nh√¢n vi√™n Sale", "NV V·∫≠n ƒë∆°n", "ƒê∆°n v·ªã v·∫≠n chuy·ªÉn"];

    const singleSelectFilterCols = [];
    const datalistFilterCols = ["M√£ ƒë∆°n h√†ng", "Name*", "Phone*", "Nh√¢n vi√™n Sale"];
    // === K·∫æT TH√öC C·∫§U H√åNH ===

    let allData = [],
      allStaffData = [], // Store all staff data here
      staffFilteredData = [],
      japanData = [],
      leaderData = [],
      mentionedData = [],
      hcmData = [],
      hanoiData = [],
      currentStaff = null,
      teamMembers = [],
      selectedCells = new Set(),
      isMouseDown = false,
      startCell = null,
      dynamicFilterOptions = {},
      japanDynamicFilterOptions = {},
      leaderDynamicFilterOptions = {},
      mentionedDynamicFilterOptions = {},
      hcmDynamicFilterOptions = {},
      hanoiDynamicFilterOptions = {},
      datalistOptions = {},
      filterDebounceTimer;


    // --- Local Storage & Status Popover Logic ---
    function updateStatusButtonUI() {
      const changes = getPendingChanges();
      const count = Object.keys(changes).length;
      const badge = document.getElementById('pending-count-badge');
      const countText = document.getElementById('pending-count-text');
      const updateInfo = document.getElementById('update-info');
      const statusButton = document.getElementById('statusButton');

      if (badge) {
        badge.textContent = count;
        badge.style.display = count > 0 ? '' : 'none';
      }

      if (countText) {
        countText.textContent = count;
      }

      if (updateInfo) {
        updateInfo.style.display = count > 0 ? '' : 'none';
      }

      if (statusButton) {
        statusButton.style.backgroundColor = count > 0 ? 'var(--accent-color)' : '#6c757d';
        // Add animation effect when there are updates
        if (count > 0) {
          statusButton.style.animation = 'pulse-glow 2s infinite';
        } else {
          statusButton.style.animation = 'none';
        }
      }
    }

    function showStatusPopover() {
      const popover = document.getElementById('status-popover');
      const listContainer = document.getElementById('pending-changes-list');
      const changes = getPendingChanges();
      const changeKeys = Object.keys(changes);

      listContainer.innerHTML = ''; // Clear previous list

      if (changeKeys.length === 0) {
        listContainer.innerHTML = '<p style="text-align: center; color: var(--text-color-muted);">Kh√¥ng c√≥ thay ƒë·ªïi n√†o ƒëang ch·ªù c·∫≠p nh·∫≠t.</p>';
      } else {
        changeKeys.forEach(primaryKey => {
          const changeData = changes[primaryKey];
          const itemDiv = document.createElement('div');
          itemDiv.className = 'pending-change-item';

          let changesHtml = `<strong>ƒê∆°n h√†ng: ${primaryKey}</strong><ul>`;
          for (const field in changeData) {
            if (field !== "M√£ ƒë∆°n h√†ng") {
              changesHtml += `<li>${field}: "<strong>${changeData[field]}</strong>"</li>`;
            }
          }
          changesHtml += '</ul>';
          itemDiv.innerHTML = changesHtml;
          listContainer.appendChild(itemDiv);
        });
      }
      popover.style.display = 'flex';
    }

    function hideStatusPopover() {
      document.getElementById('status-popover').style.display = 'none';
    }

    async function handleUpdateAllPending() {
      const payload = Object.values(getPendingChanges());

      if (payload.length === 0) {
        showTempMessage('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ c·∫≠p nh·∫≠t.', true);
        return;
      }

      const updateBtn = document.getElementById('update-all-pending');
      const originalText = updateBtn.textContent;
      updateBtn.disabled = true;
      updateBtn.textContent = 'ƒêang x·ª≠ l√Ω...';

      try {
        const response = await fetch(UPDATE_BULK_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        // Ki·ªÉm tra xem response c√≥ h·ª£p l·ªá kh√¥ng (v√≠ d·ª•: l·ªói m·∫°ng, l·ªói server 500)
        if (!response.ok) {
          // C·ªë g·∫Øng ƒë·ªçc th√¥ng b√°o l·ªói t·ª´ server n·∫øu c√≥
          const errorResult = await response.json().catch(() => null);
          throw new Error(errorResult?.message || `L·ªói t·ª´ server: ${response.statusText}`);
        }

        const result = await response.json();

        // Ki·ªÉm tra tr·∫°ng th√°i th√†nh c√¥ng trong n·ªôi dung JSON tr·∫£ v·ªÅ
        if (!result.success) {
          throw new Error(result.message || 'Server b√°o c√°o c·∫≠p nh·∫≠t kh√¥ng th√†nh c√¥ng.');
        }

        // === PH·∫¶N S·ª¨A L·ªñI CH√çNH N·∫∞M ·ªû ƒê√ÇY ===
        // 1. T·∫°o th√¥ng b√°o th√†nh c√¥ng d·ª±a tr√™n s·ªë l∆∞·ª£ng b·∫£n ghi ƒë√£ g·ª≠i ƒëi.
        showTempMessage(`C·∫≠p nh·∫≠t th√†nh c√¥ng ${payload.length} ƒë∆°n h√†ng. ƒêang ƒë·ªìng b·ªô...`);

        // 2. X√≥a c√°c thay ƒë·ªïi ƒëang ch·ªù trong localStorage v√¨ ch√∫ng ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng.
        clearPendingChanges();

        // 3. ·∫®n popover ƒëi.
        hideStatusPopover();

        // 4. Flush queue ƒë·ªÉ ƒë·∫£m b·∫£o DB ƒë∆∞·ª£c c·∫≠p nh·∫≠t tr∆∞·ªõc khi reload data
        try {
          await fetch(`${mainHost}/sync/flush-queue`, { method: 'POST' });
        } catch (e) { /* ignore flush errors */ }

        // 5. T·∫£i l·∫°i d·ªØ li·ªáu sau khi queue ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω, d√πng forceRefresh ƒë·ªÉ tr√°nh cache c≈©
        loadData(currentPage, true, true);

      } catch (error) {
        // console.error("L·ªói khi c·∫≠p nh·∫≠t t·ª´ popover:", error);
        // Hi·ªÉn th·ªã th√¥ng b√°o l·ªói, kh√¥ng x√≥a thay ƒë·ªïi ƒë·ªÉ ng∆∞·ªùi d√πng c√≥ th·ªÉ th·ª≠ l·∫°i.
        showTempMessage(`L·ªói c·∫≠p nh·∫≠t: ${error.message}. C√°c thay ƒë·ªïi v·∫´n ƒë∆∞·ª£c l∆∞u.`, true);
      } finally {
        // Lu√¥n k√≠ch ho·∫°t l·∫°i n√∫t b·∫•m d√π th√†nh c√¥ng hay th·∫•t b·∫°i.
        updateBtn.disabled = false;
        updateBtn.textContent = originalText;
      }
    }

    function handleCancelAllChanges() {
      if (Object.keys(getPendingChanges()).length === 0) {
        showTempMessage('Kh√¥ng c√≥ thay ƒë·ªïi n√†o ƒë·ªÉ h·ªßy.', true);
        return;
      }
      if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën h·ªßy t·∫•t c·∫£ c√°c thay ƒë·ªïi ch∆∞a ƒë∆∞·ª£c l∆∞u? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.')) {
        clearPendingChanges();
        showTempMessage('ƒê√£ h·ªßy t·∫•t c·∫£ c√°c thay ƒë·ªïi ƒëang ch·ªù. ƒêang t·∫£i l·∫°i d·ªØ li·ªáu...');

        // 2. ·∫®n popover
        hideStatusPopover();

        // 3. T·∫£i l·∫°i to√†n b·ªô d·ªØ li·ªáu t·ª´ server ƒë·ªÉ kh√¥i ph·ª•c tr·∫°ng th√°i g·ªëc
        // ƒê√¢y l√† b∆∞·ªõc quan tr·ªçng nh·∫•t ƒë·ªÉ s·ª≠a l·ªói
        setTimeout(loadData, 500); // Th√™m m·ªôt kho·∫£ng tr·ªÖ nh·ªè ƒë·ªÉ ng∆∞·ªùi d√πng ƒë·ªçc th√¥ng b√°o
      }
    }

    // ==========================================
    // === REAL-TIME SYNC - SSE SERVICE ===
    // ==========================================

    /**
     * Start SSE connection for real-time updates
     */
    function startSSE() {
      if (eventSource && eventSource.readyState !== EventSource.CLOSED) {
        // console.log('‚ö†Ô∏è SSE already connected');
        return;
      }

      // console.log('üîÑ Starting SSE real-time sync...');
      updateSyncIndicator('connecting');

      try {
        eventSource = new EventSource(SSE_URL);

        // Connection opened
        eventSource.addEventListener('connected', (event) => {
          // console.log('‚úÖ SSE connected:', JSON.parse(event.data));
          sseReconnectAttempts = 0; // Reset on successful connection
          updateSyncIndicator('connected');
        });

        // Receive change event
        eventSource.addEventListener('change', (event) => {
          const data = JSON.parse(event.data);
          // console.log('üì• SSE change received:', data);
          handleSSEChange(data);
        });

        // Generic message handler
        eventSource.onmessage = (event) => {
          // console.log('üì® SSE message:', event.data);
        };

        // Error handler with auto-reconnect
        eventSource.onerror = (error) => {
          // console.error('‚ùå SSE error:', error);
          updateSyncIndicator('error');

          // Close and attempt reconnect
          eventSource.close();
          eventSource = null;
          scheduleReconnect();
        };

      } catch (error) {
        // console.error('‚ùå SSE initialization error:', error);
        updateSyncIndicator('error');
        scheduleReconnect();
      }
    }

    /**
     * Stop SSE connection
     */
    function stopSSE() {
      if (eventSource) {
        eventSource.close();
        eventSource = null;
        // console.log('‚èπÔ∏è SSE stopped');
        updateSyncIndicator('disconnected');
      }
    }

    /**
     * Schedule reconnection with exponential backoff OR fallback to polling
     */
    function scheduleReconnect() {
      sseReconnectAttempts++;

      // After 3 failed attempts, switch to polling fallback
      if (sseReconnectAttempts >= SSE_MAX_RECONNECT_ATTEMPTS) {
        // console.log('‚ö†Ô∏è SSE failed too many times, switching to polling fallback');
        usePollingFallback = true;
        startPollingFallback();
        return;
      }

      const delay = Math.min(1000 * Math.pow(2, sseReconnectAttempts), SSE_MAX_RECONNECT_DELAY);

      // console.log(`üîÑ SSE reconnecting in ${delay / 1000}s (attempt ${sseReconnectAttempts})`);
      updateSyncIndicator('reconnecting');

      setTimeout(() => {
        if (!eventSource || eventSource.readyState === EventSource.CLOSED) {
          startSSE();
        }
      }, delay);
    }

    /**
     * Start polling as fallback when SSE fails
     */
    function startPollingFallback() {
      // Clear any existing interval first
      if (pollIntervalId) {
        clearInterval(pollIntervalId);
        pollIntervalId = null;
      }

      // console.log('üîÑ Starting continuous polling (5s interval)...');
      lastSyncTimestamp = Date.now();
      updateSyncIndicator('polling');

      // Run first poll immediately
      pollForChanges();

      // Then poll every 5 seconds
      pollIntervalId = setInterval(() => {
        pollForChanges();
      }, 5000); // 5 seconds
    }

    /**
     * Poll DB for updates (refresh current page)
     */
    async function pollForChanges() {
      // Skip if already syncing
      if (isSyncing) {
        // console.log('‚è≥ Skipping poll, already syncing...');
        return;
      }

      try {
        isSyncing = true;

        // Fetch current page from DB
        const url = `${DB_DATA_URL}?page=${currentPage}&limit=${pageSize}&sortBy=id&order=asc`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Poll failed: ${response.status}`);

        const result = await response.json();
        if (!result.success) throw new Error(result.message);

        // Update data silently (no loader)
        const data = result.data || [];
        totalRecords = result.meta?.total || totalRecords;
        totalPages = result.meta?.totalPages || totalPages;

        // Check if data changed (simple length check)
        const currentCount = allData?.length || 0;
        if (data.length !== currentCount || totalRecords !== currentCount) {
          // console.log(`üì• Data updated: ${data.length} rows on page ${currentPage}`);
          handleData({ rows: data });
          updatePaginationUI();
        }

        updateSyncIndicator('polling');

      } catch (error) {
        // console.error('Poll error:', error.message);
        updateSyncIndicator('error');
      } finally {
        isSyncing = false;
      }
    }

    /**
     * Stop polling fallback
     */
    function stopPollingFallback() {
      if (pollIntervalId) {
        clearInterval(pollIntervalId);
        pollIntervalId = null;
      }
    }

    /**
     * Handle SSE change event
     */
    function handleSSEChange(data) {
      if (isSyncing) {
        // console.log('‚è≥ Already processing, queuing change');
        return;
      }

      try {
        isSyncing = true;

        const primaryKey = data.primaryKey;
        const pendingChanges = getPendingChanges();

        // Check for conflict
        if (primaryKey && pendingChanges[primaryKey]) {
          showConflictWarning([primaryKey]);
          return;
        }

        // Update the specific row in allData
        if (primaryKey && data.changedFields) {
          const existingIndex = allData.findIndex(d => d['M√£ ƒë∆°n h√†ng'] === primaryKey);

          if (existingIndex >= 0) {
            // Merge changed fields
            Object.keys(data.changedFields).forEach(key => {
              allData[existingIndex][key] = data.changedFields[key];
            });

            // Also update from data directly
            if (data.newValue && data.changedFields) {
              const columnName = Object.keys(data.changedFields)[0];
              if (columnName) {
                allData[existingIndex][columnName] = data.newValue;
              }
            }
          }
        }

        // Re-render current view
        const activeConfig = allTabConfigs.find(c =>
          document.getElementById(c.table.body)?.closest('.content-tab')?.classList.contains('active')
        );

        if (activeConfig) {
          applyAllFilters(activeConfig);
        }

        // Show notification
        const user = data.user || 'Ng∆∞·ªùi kh√°c';
        showSyncNotification(`${user} v·ª´a c·∫≠p nh·∫≠t ƒë∆°n ${primaryKey || 'm·ªôt ƒë∆°n h√†ng'}`);

      } finally {
        isSyncing = false;
      }
    }

    /**
     * Handle data update from external source (Google Sheet direct edit)
     */
    function handleExternalDataUpdate(newData) {
      // console.log('üîÑ External data update received, refreshing view...');

      // Check if user has pending changes that might conflict
      const pendingChanges = getPendingChanges();
      const pendingKeys = Object.keys(pendingChanges);

      if (pendingKeys.length > 0) {
        // Find conflicts
        const conflicts = [];
        newData.forEach(row => {
          const rowKey = row['M√£ ƒë∆°n h√†ng'];
          if (pendingChanges[rowKey]) {
            conflicts.push(rowKey);
          }
        });

        if (conflicts.length > 0) {
          // Show conflict warning
          showConflictWarning(conflicts);
          return; // Don't auto-merge if there are conflicts
        }
      }

      // No conflicts, safe to update
      allData = newData;

      // Re-render table with new data
      const activeConfig = allTabConfigs.find(c =>
        document.getElementById(c.table.body)?.closest('.content-tab')?.classList.contains('active')
      );

      if (activeConfig) {
        renderTableBody(activeConfig, allData);
      }
    }

    /**
     * Smart merge of incremental changes
     */
    function mergeDataUpdates(changes) {
      changes.forEach(change => {
        const primaryKey = change['M√£ ƒë∆°n h√†ng'] || change.primaryKey;
        if (!primaryKey) return;

        const existingIndex = allData.findIndex(d => d['M√£ ƒë∆°n h√†ng'] === primaryKey);

        if (existingIndex >= 0) {
          // Update existing row
          Object.keys(change).forEach(key => {
            if (!key.startsWith('_')) { // Skip internal fields
              allData[existingIndex][key] = change[key];
            }
          });
        } else {
          // New row (shouldn't happen in normal operation)
          allData.push(change);
        }
      });

      // Re-render current view
      const activeConfig = allTabConfigs.find(c =>
        document.getElementById(c.table.body)?.closest('.content-tab')?.classList.contains('active')
      );

      if (activeConfig) {
        applyAllFilters(activeConfig);
      }
    }

    /**
     * Show conflict warning when pending changes conflict with server
     */
    function showConflictWarning(conflictingKeys) {
      const message = `‚ö†Ô∏è C√≥ ${conflictingKeys.length} ƒë∆°n h√†ng b·ªã xung ƒë·ªôt v·ªõi d·ªØ li·ªáu t·ª´ server: ${conflictingKeys.slice(0, 3).join(', ')}${conflictingKeys.length > 3 ? '...' : ''}. Vui l√≤ng c·∫≠p nh·∫≠t ho·∫∑c h·ªßy thay ƒë·ªïi c·ªßa b·∫°n.`;
      showTempMessage(message, true);

      // Highlight status button
      const statusButton = document.getElementById('statusButton');
      if (statusButton) {
        statusButton.style.backgroundColor = 'var(--danger-color)';
        statusButton.style.animation = 'pulse-glow 0.5s infinite';
      }
    }

    /**
     * Update sync status indicator in UI
     */
    function updateSyncIndicator(status) {
      let indicator = document.getElementById('sync-indicator');

      if (!indicator) {
        // Create indicator if doesn't exist
        indicator = document.createElement('span');
        indicator.id = 'sync-indicator';
        indicator.style.cssText = 'margin-left: 10px; font-size: 0.8em; display: inline-flex; align-items: center; gap: 4px;';

        const userInfo = document.getElementById('userInfo');
        if (userInfo) {
          userInfo.parentNode.insertBefore(indicator, userInfo.nextSibling);
        }
      }

      switch (status) {
        case 'connected':
          indicator.innerHTML = '<span style="color: #28a745;">‚óè</span> ƒê·ªìng b·ªô SSE';
          indicator.title = 'Real-time SSE ƒëang ho·∫°t ƒë·ªông';
          break;
        case 'polling':
          indicator.innerHTML = '<span style="color: #28a745;">‚óè</span> ƒê·ªìng b·ªô (3s)';
          indicator.title = 'Polling mode - c·∫≠p nh·∫≠t m·ªói 3 gi√¢y';
          break;
        case 'connecting':
          indicator.innerHTML = '<span style="color: #17a2b8;">‚óè</span> ƒêang k·∫øt n·ªëi...';
          indicator.title = 'ƒêang thi·∫øt l·∫≠p k·∫øt n·ªëi SSE';
          break;
        case 'reconnecting':
          indicator.innerHTML = '<span style="color: #ffc107;">‚óè</span> ƒêang k·∫øt n·ªëi l·∫°i...';
          indicator.title = 'ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i SSE';
          break;
        case 'error':
          indicator.innerHTML = '<span style="color: #dc3545;">‚óè</span> M·∫•t k·∫øt n·ªëi';
          indicator.title = 'Kh√¥ng th·ªÉ k·∫øt n·ªëi SSE';
          break;
        case 'disconnected':
          indicator.innerHTML = '<span style="color: #6c757d;">‚óè</span> Offline';
          indicator.title = 'SSE ƒë√£ d·ª´ng';
          break;
        default:
          indicator.innerHTML = '';
      }
    }

    /**
     * Show a temporary sync notification (non-intrusive)
     */
    function showSyncNotification(message) {
      // Create or get notification element
      let notification = document.getElementById('sync-notification');

      if (!notification) {
        notification = document.createElement('div');
        notification.id = 'sync-notification';
        notification.style.cssText = `
          position: fixed;
          bottom: 20px;
          right: 20px;
          background: linear-gradient(135deg, #28a745, #20c997);
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
          z-index: 10000;
          font-size: 0.9em;
          font-weight: 500;
          opacity: 0;
          transform: translateY(20px);
          transition: all 0.3s ease;
        `;
        document.body.appendChild(notification);
      }

      notification.textContent = message;
      notification.style.opacity = '1';
      notification.style.transform = 'translateY(0)';

      // Auto hide after 3 seconds
      setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transform = 'translateY(20px)';
      }, 3000);
    }

    // Backward compatibility aliases
    const startPolling = startSSE;
    const stopPolling = stopSSE;

    // ==========================================
    // === END REAL-TIME SYNC ===
    // ==========================================

    // --- Local Storage Change Management ---
    function getPendingChanges() {
      return JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    }

    function savePendingChange(primaryKey, field, value) {
      const changes = getPendingChanges();
      if (!changes[primaryKey]) {
        changes[primaryKey] = { "M√£ ƒë∆°n h√†ng": primaryKey };
      }
      changes[primaryKey][field] = value;
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(changes));
      // // console.log('Change saved to local storage:', { primaryKey, field, value });
      updateStatusButtonUI();
    }

    function removePendingChange(primaryKey) {
      const changes = getPendingChanges();
      delete changes[primaryKey];
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(changes));
      updateStatusButtonUI();
    }

    function clearPendingChanges() {
      localStorage.removeItem(LOCAL_STORAGE_KEY);
      // // console.log('Local storage cleared.');
      updateStatusButtonUI();
    }


    const mainTabConfig = { data: () => staffFilteredData, controls: { refreshBtn: 'refreshData', updateBtn: 'updateAll', clearBtn: 'clearFilters', startDate: 'startDateFilter', endDate: 'endDateFilter', product: 'productFilter', market: 'marketFilter', summary: 'summaryInfo' }, table: { head: 'tableHead', body: 'tableBody' }, dynamicOptions: () => dynamicFilterOptions };
    const japanTabConfig = { data: () => japanData, controls: { refreshBtn: 'japanRefreshData', updateBtn: 'japanUpdateAll', clearBtn: 'japanClearFilters', startDate: 'japanStartDateFilter', endDate: 'japanEndDateFilter', product: 'japanProductFilter', staff: 'japanStaffFilter', summary: 'japanSummaryInfo' }, table: { head: 'japanTableHead', body: 'japanTableBody' }, dynamicOptions: () => japanDynamicFilterOptions };
    const leaderTabConfig = { data: () => leaderData, controls: { refreshBtn: 'leaderRefreshData', updateBtn: 'leaderUpdateAll', clearBtn: 'leaderClearFilters', startDate: 'leaderStartDateFilter', endDate: 'leaderEndDateFilter', product: 'leaderProductFilter', summary: 'leaderSummaryInfo' }, table: { head: 'leaderTableHead', body: 'leaderTableBody' }, dynamicOptions: () => leaderDynamicFilterOptions };
    const mentionedTabConfig = { data: () => mentionedData, controls: { refreshBtn: 'mentionedRefreshData', updateBtn: 'mentionedUpdateAll', clearBtn: 'mentionedClearFilters', startDate: 'mentionedStartDateFilter', endDate: 'mentionedEndDateFilter', product: 'mentionedProductFilter', summary: 'mentionedSummaryInfo' }, table: { head: 'mentionedTableHead', body: 'mentionedTableBody' }, dynamicOptions: () => mentionedDynamicFilterOptions };
    const hcmTabConfig = { data: () => hcmData, controls: { refreshBtn: 'hcmRefreshData', updateBtn: 'hcmUpdateAll', clearBtn: 'hcmClearFilters', startDate: 'hcmStartDateFilter', endDate: 'hcmEndDateFilter', product: 'hcmProductFilter', staff: 'hcmStaffFilter', summary: 'hcmSummaryInfo' }, table: { head: 'hcmTableHead', body: 'hcmTableBody' }, dynamicOptions: () => hcmDynamicFilterOptions };
    const hanoiTabConfig = { data: () => hanoiData, controls: { refreshBtn: 'hanoiRefreshData', updateBtn: 'hanoiUpdateAll', clearBtn: 'hanoiClearFilters', startDate: 'hanoiStartDateFilter', endDate: 'hanoiEndDateFilter', market: 'hanoiMarketFilter', product: 'hanoiProductFilter', staff: 'hanoiStaffFilter', summary: 'hanoiSummaryInfo' }, table: { head: 'hanoiTableHead', body: 'hanoiTableBody' }, dynamicOptions: () => hanoiDynamicFilterOptions };

    const allTabConfigs = [mainTabConfig, japanTabConfig, leaderTabConfig, mentionedTabConfig, hcmTabConfig, hanoiTabConfig];

    function getDateTimeVN(dateInput) {
      let date;
      if (!dateInput) {
        date = new Date();
      } else {
        date = new Date(dateInput);
        if (isNaN(date.getTime())) {
          // // console.warn("‚ö†Ô∏è Invalid dateInput:", dateInput);
          return "Ng√†y kh√¥ng h·ª£p l·ªá";
        }
      }
      const options = { timeZone: "Asia/Ho_Chi_Minh", hour12: false };
      const vnDate = new Date(date.toLocaleString("en-US", options));
      const dd = String(vnDate.getDate()).padStart(2, "0");
      const mm = String(vnDate.getMonth() + 1).padStart(2, "0");
      const yyyy = vnDate.getFullYear();
      const HH = String(vnDate.getHours()).padStart(2, "0");
      const MM = String(vnDate.getMinutes()).padStart(2, "0");
      const SS = String(vnDate.getSeconds()).padStart(2, "0");
      return `${mm}/${dd}/${yyyy} ${HH}:${MM}:${SS}`;
    }

    function getFixedColumnCount() { const e = document.getElementById("fixedColumnCountInput"), t = parseInt(e.value, 10); return isNaN(t) || t < 0 ? 0 : t }
    function handleFixedColumnCountChange() { const newCount = getFixedColumnCount(); const activeTab = document.querySelector(".content-tab.active"); if (!activeTab) return; const activeConfig = allTabConfigs.find(c => c.table.body === activeTab.querySelector("tbody")?.id); if (!activeConfig) return; const tableHead = document.getElementById(activeConfig.table.head); const tableBody = document.getElementById(activeConfig.table.body); if (!tableHead || !tableBody) return; const allRows = [...tableHead.querySelectorAll("tr"), ...tableBody.querySelectorAll("tr")]; allRows.forEach(row => { for (let i = 0; i < row.cells.length; i++) { const cell = row.cells[i]; if (i < newCount) { cell.classList.add("fixed-column") } else { cell.classList.remove("fixed-column"); cell.style.left = "" } } }); updateStickyColumns(activeConfig) }
    function updateStickyColumns(config) { const fixedCount = getFixedColumnCount(); const tableHead = document.getElementById(config.table.head); const tableBody = document.getElementById(config.table.body);[...tableHead.querySelectorAll(".fixed-column"), ...tableBody.querySelectorAll(".fixed-column")].forEach(c => c.style.left = ""); if (fixedCount <= 0) return; const headerRow = tableHead.querySelector("tr"); if (!headerRow) return; let leftOffset = 0; for (let i = 0; i < fixedCount; i++) { const th = headerRow.cells[i]; if (!th) continue; th.style.left = leftOffset + "px"; const rows = tableBody.querySelectorAll("tr"); rows.forEach(row => { if (row.cells[i]) { row.cells[i].style.left = leftOffset + "px" } }); leftOffset += th.offsetWidth } }
    function getUrlParameter(name) { name = name.replace(/[\[\]]/g, "\\$&"); const regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"), results = regex.exec(window.location.href); if (!results) return null; if (!results[2]) return ""; return decodeURIComponent(results[2].replace(/\+/g, " ")) }
    function parseDateString(dateString) { if (!dateString || typeof dateString !== "string") return null; const cleanedDateString = dateString.trim().replace(/[^\d\/\-\s]/g, ""); if (/^\d{4}-\d{2}-\d{2}/.test(cleanedDateString)) { const d = new Date(cleanedDateString); if (!isNaN(d.getTime())) return d } const parts = cleanedDateString.match(/^(\d{1,2})[/\-](\d{1,2})[/\-](\d{4})/); if (parts) { const month = parseInt(parts[1], 10), day = parseInt(parts[2], 10), year = parseInt(parts[3], 10); if (year > 1e3 && month > 0 && month <= 12 && day > 0 && day <= 31) { const d = new Date(Date.UTC(year, month - 1, day)); if (d.getUTCFullYear() === year && d.getUTCMonth() === month - 1) return d } } return null }
    function formatDate(dateString) { const originalValue = typeof dateString === "string" ? dateString.trim() : ""; if (!originalValue) return { display: "", original: "" }; const dateObj = parseDateString(originalValue); if (dateObj) { const day = String(dateObj.getUTCDate()).padStart(2, "0"), month = String(dateObj.getUTCMonth() + 1).padStart(2, "0"), year = dateObj.getUTCFullYear(); return { display: `${day}/${month}/${year}`, original: originalValue } } return { display: originalValue, original: originalValue } }

    // --- OPTIMIZED STAFF FETCHING ---
    async function fetchAllStaffData() {
      if (allStaffData.length > 0) return allStaffData;
      try {
        const staffApiUrl = `https://n-api-rouge.vercel.app/sheet/getSheets?rangeSheet=A:K&sheetName=Nh%C3%A2n%20s%E1%BB%B1&spreadsheetId=1yUKSfBxvSF-ZOLMub0FAQRORjOQQ2ybK4hZ0h5f3xY4`;
        const response = await fetch(staffApiUrl, { cache: "no-store" });
        if (!response.ok) throw new Error("L·ªói m·∫°ng khi t·∫£i data nh√¢n vi√™n");
        const results = await response.json();
        allStaffData = results?.rows?.map(item => ({
          idnv: item['id'] || item['ID'], // Support both lowercase and uppercase ID
          ho_va_ten: item['H·ªç V√† T√™n'], bo_phan: item['B·ªô ph·∫≠n'], vi_tri: item['V·ªã tr√≠'], email: item['email'], sdt: item['SƒêT'], team: item['Team'], chi_nhanh: item['chi nh√°nh'], ca: item['Ca'], vi_tri_van_don: item['V·ªã tr√≠ v·∫≠n ƒë∆°n'], link_van_don: item['link v·∫≠n ƒë∆°n']
        })) || [];
        // Ensure we filter out rows with no ID
        allStaffData = allStaffData.filter(s => s.idnv);
        return allStaffData;
      } catch (error) {
        showError(error.message);
        throw error;
      }
    }

    async function fetchStaffInfo(idns) {
      const data = await fetchAllStaffData();
      let staffMember = data.find(staff => String(staff.idnv) === idns);
      if (!staffMember) throw new Error(`Kh√¥ng t√¨m th·∫•y nh√¢n vi√™n v·ªõi ID: ${idns}`);

      const memberNames = new Set();
      if (staffMember) {
        if (staffMember.ho_va_ten) memberNames.add(staffMember.ho_va_ten);
        if (staffMember.vi_tri === "Leader" && staffMember.team) {
          const teamName = staffMember.team;
          data.forEach(member => {
            if (member.team === teamName && member.ho_va_ten) memberNames.add(member.ho_va_ten);
          });
        }
      }
      teamMembers = Array.from(memberNames);
      return staffMember;
    }

    async function fetchMultipleStaffInfo(idArray) {
      if (!idArray || idArray.length === 0) return [];
      const data = await fetchAllStaffData();
      const staffNames = new Set();
      idArray.forEach(id => {
        const staffMember = data.find(staff => String(staff.idnv) === id.trim());
        if (staffMember && staffMember.ho_va_ten) {
          staffNames.add(staffMember.ho_va_ten);
        }
      });
      if (staffNames.size === 0) {
        // // console.warn("Kh√¥ng t√¨m th·∫•y nh√¢n vi√™n n√†o h·ª£p l·ªá cho c√°c ID trong id1:", idArray);
      }
      return Array.from(staffNames);
    }

    function showError(message, containerId = "tableBody") { const container = document.getElementById(containerId), colCount = displayColumns.length; container.innerHTML = `<tr><td colspan="${colCount}" class="no-data" style="text-align: center;">${message}</td></tr>` }
    function updateSummaryInfo(config) {
      const tableBody = document.getElementById(config.table.body);
      const summaryElement = document.getElementById(config.controls.summary);

      // ƒê·∫øm s·ªë rows visible trong DOM (cho filter case)
      let visibleCount = 0;
      let totalAmount = 0;

      // Duy·ªát qua t·ª´ng row trong table ƒë·ªÉ t√≠nh t·ªïng ti·ªÅn c·ªßa trang hi·ªán t·∫°i
      tableBody.querySelectorAll('tr').forEach(tr => {
        if (tr.style.display !== 'none') {
          visibleCount++;

          // L·∫•y gi√° tr·ªã "T·ªïng ti·ªÅn VNƒê" ho·∫∑c "Gi√° b√°n" t·ª´ DOM 
          // T√¨m c·ªôt ch·ª©a gi√° tr·ªã ti·ªÅn (th∆∞·ªùng ·ªü c√°c c·ªôt cu·ªëi)
          const orderCodeCell = tr.cells[0];
          const orderCode = orderCodeCell ? getDOMCellValue(orderCodeCell) : null;

          if (orderCode) {
            // T√¨m trong allData (data c·ªßa trang hi·ªán t·∫°i)
            const rowData = allData.find(item => item["M√£ ƒë∆°n h√†ng"] === orderCode);

            if (rowData) {
              let amountValue = rowData["T·ªïng ti·ªÅn VNƒê"] ||
                rowData["T·ªïng_ti·ªÅn_VNƒê"] ||
                rowData["T·ªïng ti·ªÅn VND"] ||
                rowData["T·ªïng_ti·ªÅn_VND"] ||
                rowData["Gi√° b√°n"] ||
                rowData["Gi√°_b√°n"] ||
                0;

              const numericValue = parseFloat(String(amountValue).replace(/[^\d.-]/g, "")) || 0;
              totalAmount += numericValue;
            }
          }
        }
      });

      const formattedAmount = new Intl.NumberFormat("vi-VN", { style: "currency", currency: "VND" }).format(totalAmount);
      summaryElement.innerHTML = `T·ªïng ƒë∆°n: <b>${visibleCount}</b> | T·ªïng ti·ªÅn: <b style="color:var(--success-color)">${formattedAmount}</b>`;

      // Update pagination bar with summary - ch·ªâ update n·∫øu c√≥ visible rows
      if (typeof updateCachedSummary === 'function' && visibleCount > 0) {
        updateCachedSummary(visibleCount, totalAmount);
      }
    }
    function getDOMCellValue(e) { if (!e) return ""; const t = e.querySelector("select"); if (t) return t.value; const n = e.querySelector("input"); return n ? n.value : e.textContent.trim() }

    // üîß Helper function to get "M√£ ƒë∆°n h√†ng" from selected cell
    function getOrderCodeFromCell(cell) {
      try {
        const tr = cell.closest('tr');
        if (!tr) return 'N/A';

        // üî• FIX: L·∫•y "M√£ ƒë∆°n h√†ng" tr·ª±c ti·∫øp t·ª´ DOM thay v√¨ d·ª±a v√†o rowIndex
        // C·ªôt "M√£ ƒë∆°n h√†ng" lu√¥n l√† c·ªôt ƒë·∫ßu ti√™n (index 0)
        const orderCodeCell = tr.cells[0]; // displayColumns[0] = "M√£ ƒë∆°n h√†ng"
        if (!orderCodeCell) return 'N/A';

        // L·∫•y gi√° tr·ªã tr·ª±c ti·∫øp t·ª´ DOM cell
        const orderCode = getDOMCellValue(orderCodeCell);
        return orderCode || 'N/A';
      } catch (error) {
        // // console.warn('Error getting order code:', error);
        return 'ERROR';
      }
    }
    function updateSelectionSummary() { const summaryEl = document.getElementById("selectionSummary"); if (!summaryEl || !document.getElementById("contentData").classList.contains("active")) { if (summaryEl) summaryEl.innerHTML = ""; return } if (selectedCells.size <= 1) { summaryEl.innerHTML = ""; return } let totalSum = 0, numericCount = 0, nonBlankCount = 0; selectedCells.forEach(cell => { const value = getDOMCellValue(cell); if (value !== "") nonBlankCount++; const numericValue = parseFloat(String(value).replace(/[^0-9.-]/g, "")); if (!isNaN(numericValue)) { totalSum += numericValue; numericCount++ } }); let summaryParts = [`Count: <b>${nonBlankCount}</b>`]; if (numericCount > 0) summaryParts.push(`Sum: <b>${totalSum.toLocaleString("vi-VN")}</b>`); summaryEl.innerHTML = summaryParts.join(" | ") }
    function setupCellSelection(tableBodyId) { const tableBody = document.getElementById(tableBodyId); if (!tableBody) return; let lastClickTime = 0, lastClickCell = null; tableBody.addEventListener("mousedown", e => { const td = e.target.closest("td"); if (!td) return; if (e.target.tagName === "SELECT" || e.target.tagName === "INPUT") return; if (!e.ctrlKey && !e.metaKey && !e.shiftKey) { isMouseDown = !0; startCell = td; selectedCells.forEach(cell => cell.classList.remove("cell-selected")); selectedCells.clear(); td.classList.add("cell-selected"); selectedCells.add(td); e.preventDefault() } }); tableBody.addEventListener("click", e => { const td = e.target.closest("td"); if (!td) return; if (e.target.tagName === "SELECT" || e.target.tagName === "INPUT") return; const currentTime = (new Date).getTime(), isDoubleClick = currentTime - lastClickTime < 300 && lastClickCell === td; if (isDoubleClick) handleEditCell(td, tableBodyId); else { if (e.shiftKey && startCell) selectCellsBetween(startCell, td); else if (e.ctrlKey || e.metaKey) { td.classList.toggle("cell-selected"); if (td.classList.contains("cell-selected")) selectedCells.add(td); else selectedCells.delete(td) } else { selectedCells.forEach(cell => cell.classList.remove("cell-selected")); selectedCells.clear(); td.classList.add("cell-selected"); selectedCells.add(td) } startCell = td } lastClickTime = currentTime; lastClickCell = td; updateSelectionSummary() }); tableBody.addEventListener("mouseover", e => { if (isMouseDown) { const td = e.target.closest("td"); if (td) selectCellsBetween(startCell, td) } }); document.addEventListener("mouseup", () => { if (isMouseDown) { isMouseDown = !1; updateSelectionSummary() } }) }
    function selectCellsBetween(start, end) {
      if (!start || !end || start.closest("tbody") !== end.closest("tbody")) return;

      const tableBody = start.closest("tbody");
      const allRows = Array.from(tableBody.rows);
      if (allRows.length === 0) return;

      const startRowIndex = allRows.findIndex(row => row.contains(start));
      const endRowIndex = allRows.findIndex(row => row.contains(end));
      const startColIndex = start.cellIndex;
      const endColIndex = end.cellIndex;

      const minRow = Math.min(startRowIndex, endRowIndex);
      const maxRow = Math.max(startRowIndex, endRowIndex);
      const minCol = Math.min(startColIndex, endColIndex);
      const maxCol = Math.max(startColIndex, endColIndex);

      // X√≥a l·ª±a ch·ªçn c≈© v√† x√¢y d·ª±ng l·∫°i t·ª´ ƒë·∫ßu ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh ƒë√∫ng ƒë·∫Øn
      selectedCells.forEach(cell => cell.classList.remove("cell-selected"));
      selectedCells.clear();

      for (let i = minRow; i <= maxRow; i++) {
        for (let j = minCol; j <= maxCol; j++) {
          const cell = allRows[i]?.cells[j];
          if (cell) {
            cell.classList.add("cell-selected");
            selectedCells.add(cell);
          }
        }
      }

      // üîç LOG: Khi ch·ªçn cells (c√≥ th·ªÉ b·∫≠t/t·∫Øt khi c·∫ßn debug)
      // console.log('üîµ Cell selection updated');
      // console.log('Selected cells count:', selectedCells.size);
      // console.log('Selected cells:', Array.from(selectedCells));
      // // console.log('T·ªïng s·ªë √¥ ƒë∆∞·ª£c ch·ªçn:', selectedCells.size);
      // // console.log('Chi ti·∫øt selection:', Array.from(selectedCells).map(cell => ({
      //   orderCode: getOrderCodeFromCell(cell),
      //   text: cell.textContent.trim(),
      //   rowDisplay: cell.parentNode.style.display,
      //   isHidden: cell.parentNode.style.display === 'none',
      //   rowIndex: cell.parentNode.rowIndex,
      //   colIndex: cell.cellIndex,
      //   colName: displayColumns[cell.cellIndex]
      // })));
    }
    async function processCellUpdate(primaryKey, updates) {
      // Use DB_UPDATE_URL (v√≠a queue) for consistency
      const payload = {
        maDonHang: primaryKey,
        ...updates
      };
      try {
        const response = await fetch(DB_UPDATE_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const result = await response.json();

        if (!response.ok || !result.success) {
          throw new Error(result.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ server');
        }

        // flush queue and reload data to ensure consistency
        try {
          await fetch(`${mainHost}/sync/flush-queue`, { method: 'POST' });
        } catch (e) { /* ignore flush errors */ }

        showTempMessage(`ƒê√£ c·∫≠p nh·∫≠t ƒë∆°n ${primaryKey}`);
        removePendingChange(primaryKey); // X√≥a kh·ªèi local storage n·∫øu th√†nh c√¥ng

        // Reload data quietly to update potential edge cases
        loadData(currentPage, false, true);
      } catch (error) {
        // console.error("L·ªói khi c·∫≠p nh·∫≠t t·ª©c th√¨:", error);
        showTempMessage(`L·ªói c·∫≠p nh·∫≠t ƒë∆°n ${primaryKey}: ${error.message}. ƒê√£ l∆∞u t·∫°m.`, true);
        Object.entries(updates).forEach(([field, value]) => {
          savePendingChange(primaryKey, field, value); // L∆∞u v√†o local storage n·∫øu th·∫•t b·∫°i
        });
      }
    }

    function handleEditCell(td, tableBodyId) {
      if (!td.classList.contains("editable") || td.classList.contains("editing") || td.querySelector("select")) return;
      const dateInput = td.querySelector("input.date-input");
      if (dateInput) {
        dateInput.focus();
        return
      }
      const originalValue = td.textContent,
        input = document.createElement("input");
      input.type = "text";
      input.value = originalValue;
      td.textContent = "";
      td.appendChild(input);
      td.classList.add("editing");
      input.focus();

      const finishEdit = save => {
        const newValue = save ? input.value.trim() : originalValue;
        td.textContent = newValue;
        td.classList.remove("editing");
        if (save && newValue !== originalValue) {
          td.classList.add("highlight");
          const tr = td.closest("tr");
          const colName = displayColumns[td.cellIndex];

          // üî• FIX: L·∫•y primaryKey tr·ª±c ti·∫øp t·ª´ DOM thay v√¨ d·ª±a v√†o rowIndex
          const primaryKey = getOrderCodeFromCell(td);

          if (primaryKey && primaryKey !== 'N/A') {
            const config = allTabConfigs.find(c => c.table.body === tableBodyId);
            if (config) {

              // C·∫≠p nh·∫≠t allData
              if (allData && allData.length > 0) {
                const allDataIndex = allData.findIndex(item => item["M√£ ƒë∆°n h√†ng"] === primaryKey);
                if (allDataIndex !== -1) {
                  allData[allDataIndex][colName] = newValue;

                  if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                    const timestamp = getDateTimeVN();
                    // // console.log(`üõ†Ô∏è C·∫≠p nh·∫≠t "Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2" cho ƒë∆°n ${primaryKey} th√†nh ${timestamp}`);

                    allData[allDataIndex]["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;

                    // C·∫≠p nh·∫≠t giao di·ªán
                    const dateColIndex = displayColumns.indexOf("Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2");
                    if (dateColIndex > -1 && tr.cells[dateColIndex]) {
                      tr.cells[dateColIndex].textContent = timestamp;
                      tr.cells[dateColIndex].classList.add('highlight');
                    }
                  }
                } else {
                  // console.error('‚ùå Kh√¥ng t√¨m th·∫•y order code trong allData:', primaryKey);
                }
              }
            }

            const updates = { [colName]: newValue };
            if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
              const timestamp = getDateTimeVN();
              updates["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
            }

            processCellUpdate(primaryKey, updates);
          } else {
            // console.error('‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c primary key t·ª´ DOM!');
          }
        }
        input.removeEventListener("blur", onBlur);
        input.removeEventListener("keydown", onKeyDown);
      };

      const onBlur = () => finishEdit(true);
      const onKeyDown = e => {
        if (e.key === "Enter") {
          e.preventDefault();
          finishEdit(true);
        } else if (e.key === "Escape") {
          e.preventDefault();
          finishEdit(false);
        }
      };
      input.addEventListener("blur", onBlur);
      input.addEventListener("keydown", onKeyDown);
    }
    function copySelectedCells() {
      // 1. L·ªçc ra ch·ªâ nh·ªØng √¥ ƒëang ƒë∆∞·ª£c hi·ªÉn th·ªã (c√≥ h√†ng cha kh√¥ng b·ªã ·∫©n)
      const visibleSelectedCells = Array.from(selectedCells).filter(
        cell => cell.parentNode.style.display !== 'none'
      );

      if (visibleSelectedCells.length === 0) {
        showTempMessage('Kh√¥ng c√≥ √¥ n√†o hi·ªÉn th·ªã ƒë·ªÉ sao ch√©p.');
        return;
      }

      // 2. Nh√≥m c√°c √¥ theo h√†ng (d√πng Map ƒë·ªÉ duy tr√¨ th·ª© t·ª±)
      const rows = new Map();
      visibleSelectedCells.forEach(cell => {
        const rowIndex = cell.parentNode.rowIndex; // L·∫•y ch·ªâ s·ªë h√†ng ƒë·ªÉ s·∫Øp x·∫øp
        if (!rows.has(rowIndex)) {
          rows.set(rowIndex, []);
        }
        rows.get(rowIndex).push(cell);
      });

      // 3. S·∫Øp x·∫øp c√°c h√†ng v√† t·∫°o chu·ªói TSV (Tab-Separated Values)
      const sortedRowKeys = Array.from(rows.keys()).sort((a, b) => a - b);

      const tsv = sortedRowKeys.map(rowIndex => {
        const cellsInRow = rows.get(rowIndex);
        // S·∫Øp x·∫øp c√°c √¥ trong c√πng m·ªôt h√†ng theo ƒë√∫ng th·ª© t·ª± c·ªôt
        return cellsInRow
          .sort((a, b) => a.cellIndex - b.cellIndex)
          .map(cell => getDOMCellValue(cell)) // L·∫•y gi√° tr·ªã t·ª´ √¥
          .join('\t'); // Ph√¢n t√°ch c√°c √¥ b·∫±ng k√Ω t·ª± tab
      }).join('\n'); // Ph√¢n t√°ch c√°c h√†ng b·∫±ng k√Ω t·ª± xu·ªëng d√≤ng

      // 4. Ghi v√†o b·ªô nh·ªõ t·∫°m
      navigator.clipboard.writeText(tsv).then(
        () => showTempMessage(`ƒê√£ sao ch√©p ${visibleSelectedCells.length} √¥ ƒëang hi·ªÉn th·ªã.`),
        err => { /* ignore copy error */ }
      );
    }
    async function pasteToSelectedCells(text) {
      if (selectedCells.size === 0) return;

      // // console.log(`üöÄ === B·∫ÆT ƒê·∫¶U PASTE ===`);
      // // console.log(`üìã D·ªØ li·ªáu paste:`, text);

      // // üîç LOG: Chi ti·∫øt t·∫•t c·∫£ √¥ ƒë√£ ƒë∆∞·ª£c SELECTED
      // // console.log(`üìç SELECTED CELLS (${selectedCells.size} √¥):`);
      // Array.from(selectedCells).forEach((cell, index) => {
      //   const orderCode = getOrderCodeFromCell(cell);
      //   const colName = displayColumns[cell.cellIndex];
      //   const currentValue = getDOMCellValue(cell);
      //   const isVisible = cell.parentNode.style.display !== 'none';
      //   // console.log(`  [${index}] ${orderCode} | C·ªôt: ${colName} | Gi√° tr·ªã: "${currentValue}" | Hi·ªÉn th·ªã: ${isVisible}`);
      // });

      // üîç LOG: T·∫•t c·∫£ √¥ ƒë∆∞·ª£c ch·ªçn (k·ªÉ c·∫£ b·ªã ·∫©n)
      // // console.log('=== PASTE DEBUG ===');
      // // console.log('T·ªïng s·ªë √¥ ƒë√£ ch·ªçn:', selectedCells.size);
      // // console.log('Chi ti·∫øt c√°c √¥ ƒë√£ ch·ªçn:', Array.from(selectedCells).map(cell => ({
      //   orderCode: getOrderCodeFromCell(cell),
      //   text: cell.textContent.trim(),
      //   rowDisplay: cell.parentNode.style.display,
      //   rowIndex: cell.parentNode.rowIndex,
      //   colIndex: cell.cellIndex,
      //   colName: displayColumns[cell.cellIndex],
      //   isHidden: cell.parentNode.style.display === 'none'
      // })));

      const dataGrid = text.split("\n").map(row => row.split("\t"));

      // üî• FIX: L·ªçc ch·ªâ nh·ªØng √¥ t·ª´ h√†ng hi·ªÉn th·ªã
      const visibleSelectedCells = Array.from(selectedCells).filter(
        cell => cell.parentNode.style.display !== 'none'
      );

      // üîç LOG: √î sau khi l·ªçc
      // // console.log('S·ªë √¥ hi·ªÉn th·ªã sau l·ªçc:', visibleSelectedCells.length);
      // // console.log('Chi ti·∫øt c√°c √¥ hi·ªÉn th·ªã:', visibleSelectedCells.map(cell => ({
      //   orderCode: getOrderCodeFromCell(cell),
      //   text: cell.textContent.trim(),
      //   rowIndex: cell.parentNode.rowIndex,
      //   colIndex: cell.cellIndex,
      //   colName: displayColumns[cell.cellIndex]
      // })));

      if (visibleSelectedCells.length === 0) {
        showTempMessage('Kh√¥ng c√≥ √¥ n√†o hi·ªÉn th·ªã ƒë·ªÉ paste.');
        return;
      }

      const sortedCells = visibleSelectedCells.sort((a, b) => a.parentNode.rowIndex - b.parentNode.rowIndex || a.cellIndex - b.cellIndex);
      const firstCell = sortedCells[0];
      const table = firstCell.closest("table");

      if (!table) return;

      const startRowIndex = Array.from(table.rows).indexOf(firstCell.closest("tr"));
      const startColIndex = firstCell.cellIndex;
      let pasteCount = 0;
      const batchUpdates = [];

      if (dataGrid.length === 1 && dataGrid[0].length === 1) {
        // TR∆Ø·ªúNG H·ª¢P: COPY 1 √î, PASTE V√ÄO NHI·ªÄU √î
        const value = dataGrid[0][0];
        sortedCells.forEach(cell => {
          if (cell && cell.classList.contains("editable")) {
            const tr = cell.closest("tr");
            const config = allTabConfigs.find(cfg => cfg.table.body === cell.closest("tbody").id);
            if (!tr || !config) return;

            const rowIndex = parseInt(tr.dataset.rowIndex);
            const colName = displayColumns[cell.cellIndex];

            // üî• FIX: L·∫•y primaryKey tr·ª±c ti·∫øp t·ª´ DOM thay v√¨ d·ª±a v√†o rowIndex
            const primaryKey = getOrderCodeFromCell(cell);

            if (primaryKey && primaryKey !== 'N/A' && getDOMCellValue(cell) !== value) {
              // // console.log(`‚úÖ PASTE TH·ª∞C T·∫æ: ${primaryKey} | C·ªôt: ${colName} | "${getDOMCellValue(cell)}" ‚Üí "${value}" | DOM rowIndex: ${rowIndex}`);

              // 1. C·∫≠p nh·∫≠t giao di·ªán
              cell.textContent = value;
              cell.classList.add("highlight");

              // === START: CODE ƒê√É S·ª¨A L·ªñI (Tr∆∞·ªùng h·ª£p 1) ===
              // 2. C·∫≠p nh·∫≠t m·∫£ng d·ªØ li·ªáu JavaScript (n·∫øu c√≥ rowIndex h·ª£p l·ªá)
              const dataArray = config.data();
              // // console.log('dataArray:', dataArray);

              if (dataArray && !isNaN(rowIndex) && dataArray[rowIndex] && primaryKey === dataArray[rowIndex]["M√£ ƒë∆°n h√†ng"]) {
                // // console.log(`üîÑ C·∫≠p nh·∫≠t dataArray[${rowIndex}]: "${dataArray[rowIndex]["M√£ ƒë∆°n h√†ng"]}" - tr∆∞·ªõc: "${dataArray[rowIndex][colName]}" ‚Üí sau: "${value}"`);
                dataArray[rowIndex][colName] = value;
                if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                  const timestamp = getDateTimeVN();
                  dataArray[rowIndex]["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
                  // C·∫≠p nh·∫≠t giao di·ªán cho c·ªôt ng√†y th√°ng
                  const dateColIndex = displayColumns.indexOf("Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2");
                  if (dateColIndex > -1 && tr.cells[dateColIndex]) {
                    tr.cells[dateColIndex].textContent = timestamp;
                    tr.cells[dateColIndex].classList.add('highlight');
                  }
                }
              }

              // üî• FIX: C·∫≠p nh·∫≠t allData ƒë·ªÉ ƒë·ªìng b·ªô khi paste "ƒê∆°n v·ªã v·∫≠n chuy·ªÉn"
              if (allData && allData.length > 0) {
                const allDataIndex = allData.findIndex(item => item["M√£ ƒë∆°n h√†ng"] === primaryKey);
                if (allDataIndex !== -1) {
                  allData[allDataIndex][colName] = value;

                  if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                    const timestamp = getDateTimeVN();
                    allData[allDataIndex]["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
                    // // console.log(`üîÑ Updated allData for paste: ${primaryKey} - ${colName} = "${value}", timestamp = ${timestamp}`);
                  }
                }
              }
              // === END: CODE ƒê√É S·ª¨A L·ªñI ===

              // 3. Chu·∫©n b·ªã d·ªØ li·ªáu cho batch update (API)
              const updates = {
                [colName]: value
              };
              if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                updates["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = getDateTimeVN();
              }
              batchUpdates.push({
                "M√£ ƒë∆°n h√†ng": primaryKey,
                ...updates
              });
              pasteCount++;
            }
          }
        });
      } else {
        // TR∆Ø·ªúNG H·ª¢P: COPY NHI·ªÄU √î, PASTE V√ÄO B·∫¢NG
        dataGrid.forEach((row, r) => {
          row.forEach((value, c) => {
            const targetRow = table.rows[startRowIndex + r];
            if (targetRow && targetRow.style.display !== 'none') {
              const targetCell = targetRow.cells[startColIndex + c];
              if (targetCell && targetCell.classList.contains("editable")) {
                const tr = targetCell.closest("tr");
                const config = allTabConfigs.find(cfg => cfg.table.body === targetCell.closest("tbody").id);
                if (!config) return;

                const rowIndex = parseInt(tr.dataset.rowIndex);
                const colName = displayColumns[targetCell.cellIndex];

                // üî• FIX: L·∫•y primaryKey tr·ª±c ti·∫øp t·ª´ DOM thay v√¨ d·ª±a v√†o rowIndex
                const primaryKey = getOrderCodeFromCell(targetCell);

                if (primaryKey && primaryKey !== 'N/A' && getDOMCellValue(targetCell) !== value) {
                  // // console.log(`‚úÖ PASTE GRID: ${primaryKey} | C·ªôt: ${colName} | "${getDOMCellValue(targetCell)}" ‚Üí "${value}" | DOM rowIndex: ${rowIndex} | Grid[${r}][${c}]`);

                  // 1. C·∫≠p nh·∫≠t giao di·ªán
                  targetCell.textContent = value;
                  targetCell.classList.add("highlight");

                  // === START: CODE ƒê√É S·ª¨A L·ªñI (Tr∆∞·ªùng h·ª£p 2) ===
                  // 2. C·∫≠p nh·∫≠t m·∫£ng d·ªØ li·ªáu JavaScript (n·∫øu c√≥ rowIndex h·ª£p l·ªá)
                  const dataArray = config.data();
                  if (dataArray && !isNaN(rowIndex) && dataArray[rowIndex]) {
                    dataArray[rowIndex][colName] = value;
                    if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                      const timestamp = getDateTimeVN();
                      dataArray[rowIndex]["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
                      // C·∫≠p nh·∫≠t giao di·ªán cho c·ªôt ng√†y th√°ng
                      const dateColIndex = displayColumns.indexOf("Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2");
                      if (dateColIndex > -1 && tr.cells[dateColIndex]) {
                        tr.cells[dateColIndex].textContent = timestamp;
                        tr.cells[dateColIndex].classList.add('highlight');
                      }
                    }
                  }
                  // === END: CODE ƒê√É S·ª¨A L·ªñI ===

                  // 3. Chu·∫©n b·ªã d·ªØ li·ªáu cho batch update (API)
                  const updates = {
                    [colName]: value
                  };
                  if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                    updates["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = getDateTimeVN();
                  }
                  batchUpdates.push({
                    "M√£ ƒë∆°n h√†ng": primaryKey,
                    ...updates
                  });
                  pasteCount++;
                }
              }
            }
          })
        });
      }

      if (batchUpdates.length > 0) {
        // üîç LOG: Payload s·∫Ω g·ª≠i ƒëi
        // // console.log('=== PAYLOAD WILL BE SENT ===');
        // // console.log('S·ªë b·∫£n ghi s·∫Ω g·ª≠i:', batchUpdates.length);
        // // console.log('Chi ti·∫øt payload:', batchUpdates);
        // // console.log('==========================================');

        try {
          // Add spreadsheetId to EACH update item in the batch
          const payload = batchUpdates.map(item => ({
            ...item,
            spreadsheetId: '1yUKSfBxvSF-ZOLMub0FAQRORjOQQ2ybK4hZ0h5f3xY4'
          }));

          const response = await fetch(UPDATE_BULK_URL, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(batchUpdates)
          });
          const result = await response.json();

          if (!response.ok || !result.success) {
            throw new Error(result.message || 'L√¥i kh√¥ng x√°c ƒë·ªãnh t·ª´ server');
          }

          // flush queue and reload
          try {
            await fetch(`${mainHost}/sync/flush-queue`, { method: 'POST' });
          } catch (e) { }

          showTempMessage(`ƒê√£ d√°n v√† c·∫≠p nh·∫≠t th√†nh c√¥ng ${pasteCount} √¥.`);
          loadData(currentPage, true, true);

          // üîÑ ƒê·ªìng b·ªô h√≥a v·ªõi allData sau khi API th√†nh c√¥ng
          batchUpdates.forEach(update => {
            const orderCode = update["M√£ ƒë∆°n h√†ng"];
            // // console.log(`üíæ ƒê·ªìng b·ªô v·ªõi allData: t√¨m order code "${orderCode}"`);
            if (allData && allData.length > 0) {
              const allDataIndex = allData.findIndex(item => item["M√£ ƒë∆°n h√†ng"] === orderCode);
              if (allDataIndex !== -1) {
                Object.entries(update).forEach(([colName, value]) => {
                  if (colName !== "M√£ ƒë∆°n h√†ng") {
                    // // console.log(`‚úÖ allData[${allDataIndex}] c·∫≠p nh·∫≠t ${colName}: "${allData[allDataIndex][colName]}" ‚Üí "${value}"`);
                    allData[allDataIndex][colName] = value;

                    // üî• FIX: C·∫≠p nh·∫≠t timestamp v√†o DOM khi paste "ƒê∆°n v·ªã v·∫≠n chuy·ªÉn"
                    if (colName === "ƒê∆°n v·ªã v·∫≠n chuy·ªÉn") {
                      // T√¨m row t∆∞∆°ng ·ª©ng trong DOM ƒë·ªÉ c·∫≠p nh·∫≠t c·ªôt timestamp
                      const activeTableBody = document.querySelector('.content-tab.active tbody');
                      if (activeTableBody) {
                        const rows = Array.from(activeTableBody.querySelectorAll('tr'));
                        const targetRow = rows.find(row => {
                          const orderCodeCell = row.cells[0];
                          return orderCodeCell && getDOMCellValue(orderCodeCell) === orderCode;
                        });

                        if (targetRow) {
                          const dateColIndex = displayColumns.indexOf("Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2");
                          if (dateColIndex > -1 && targetRow.cells[dateColIndex]) {
                            const timestampFromUpdate = update["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"];
                            if (timestampFromUpdate) {
                              targetRow.cells[dateColIndex].textContent = timestampFromUpdate;
                              targetRow.cells[dateColIndex].classList.add('highlight');
                              // // console.log(`üïê Updated timestamp in DOM for order ${orderCode}: ${timestampFromUpdate}`);
                            }
                          }
                        }
                      }
                    }
                  }
                });
              } else {
                // console.log(`‚ùå Kh√¥ng t√¨m th·∫•y order code "${orderCode}" trong allData`);
              }
            }
            removePendingChange(orderCode);
          });

        } catch (error) {
          // console.error("L·ªói khi c·∫≠p nh·∫≠t h√†ng lo·∫°t sau khi d√°n:", error);
          showTempMessage(`ƒê√£ d√°n ${pasteCount} gi√° tr·ªã nh∆∞ng c√≥ l·ªói khi l∆∞u. ƒê√£ l∆∞u thay ƒë·ªïi t·∫°m th·ªùi.`, true);

          batchUpdates.forEach(update => {
            const primaryKey = update["M√£ ƒë∆°n h√†ng"];
            Object.entries(update).forEach(([field, value]) => {
              if (field !== "M√£ ƒë∆°n h√†ng") {
                savePendingChange(primaryKey, field, value);
              }
            });
          });
        }
      } else if (pasteCount > 0) {
        showTempMessage(`ƒê√£ d√°n ${pasteCount} gi√° tr·ªã (kh√¥ng c√≥ thay ƒë·ªïi m·ªõi).`);
      }
      updateSelectionSummary();
    }
    function clearSelectedCells() {
      // // console.log('üî• clearSelectedCells() called');
      // // console.log('Selected cells count:', selectedCells.size);
      if (selectedCells.size === 0) {
        // console.log('‚ùå No cells selected');
        return;
      }

      const batchUpdates = [];
      let clearCount = 0;

      selectedCells.forEach((cell, index) => {
        // // console.log(`Processing cell ${index + 1}:`, cell);
        // // console.log(`Cell editable:`, cell.classList.contains('editable'));

        if (cell && cell.classList.contains("editable")) {
          const currentValue = getDOMCellValue(cell);
          if (currentValue !== "") {  // Ch·ªâ x·ª≠ l√Ω n·∫øu cell c√≥ gi√° tr·ªã
            const primaryKey = getOrderCodeFromCell(cell);
            const colName = displayColumns[cell.cellIndex];

            // // console.log(`üîë Primary key: ${primaryKey}, Column: ${colName}, Current value: "${currentValue}"`);

            if (primaryKey && primaryKey !== 'N/A' && primaryKey !== 'ERROR') {
              // 1. C·∫≠p nh·∫≠t giao di·ªán ngay l·∫≠p t·ª©c
              const select = cell.querySelector("select");
              if (select) {
                // üî• FIX: Set flag ƒë·ªÉ tr√°nh g·ªçi API ƒë∆°n l·∫ª trong s·ª± ki·ªán change
                select.dataset.isBulkClear = "true";
                select.value = "";
                select.dispatchEvent(new Event("change", { bubbles: true }));
              } else {
                cell.textContent = "";
              }
              cell.classList.add("highlight");

              // 2. C·∫≠p nh·∫≠t d·ªØ li·ªáu local
              const tr = cell.closest("tr");
              const config = allTabConfigs.find(c => c.table.body === cell.closest("tbody").id);
              const rowIndex = parseInt(tr.dataset.rowIndex);

              if (config && !isNaN(rowIndex)) {
                const dataArray = config.data();
                if (dataArray && dataArray[rowIndex]) {
                  dataArray[rowIndex][colName] = "";
                  if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                    const timestamp = getDateTimeVN();
                    dataArray[rowIndex]["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
                  }
                }
              }

              // üî• FIX: C·∫≠p nh·∫≠t allData ƒë·ªÉ ƒë·ªìng b·ªô khi b·ªè l·ªçc
              if (allData && allData.length > 0) {
                const allDataIndex = allData.findIndex(item => item["M√£ ƒë∆°n h√†ng"] === primaryKey);
                if (allDataIndex !== -1) {
                  // // console.log(`üîÑ Updating allData[${allDataIndex}] for order ${primaryKey}: ${colName} = ""`);
                  allData[allDataIndex][colName] = "";

                  if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                    const timestamp = getDateTimeVN();
                    allData[allDataIndex]["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;

                    // C·∫≠p nh·∫≠t giao di·ªán cho c·ªôt timestamp n·∫øu hi·ªÉn th·ªã
                    const dateColIndex = displayColumns.indexOf("Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2");
                    if (dateColIndex > -1 && tr.cells[dateColIndex]) {
                      tr.cells[dateColIndex].textContent = timestamp;
                      tr.cells[dateColIndex].classList.add('highlight');
                    }
                  }
                } else {
                  // // console.warn(`‚ö†Ô∏è Could not find order ${primaryKey} in allData for clearing`);
                }
              }

              // 3. Chu·∫©n b·ªã d·ªØ li·ªáu cho batch update
              const updates = { [colName]: "" };
              if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                updates["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = getDateTimeVN();
              }

              batchUpdates.push({
                "M√£ ƒë∆°n h√†ng": primaryKey,
                ...updates
              });

              clearCount++;
              // // console.log(`‚úÖ Cell ${index + 1} prepared for clearing`);
            } else {
              // console.log(`‚ùå Invalid primary key for cell ${index + 1}`);
            }
          } else {
            // // console.log(`‚ÑπÔ∏è Cell ${index + 1} already empty`);
          }
        } else {
          // console.log(`‚ùå Cell ${index + 1} is not editable`);
        }
      });

      // // console.log(`Total cells to clear: ${clearCount}`);
      // // console.log('Batch updates payload:', batchUpdates);

      // 4. G·ªçi API bulk update n·∫øu c√≥ d·ªØ li·ªáu
      if (batchUpdates.length > 0) {
        processBulkClearUpdate(batchUpdates, clearCount);
      } else {
        showTempMessage('Kh√¥ng c√≥ √¥ n√†o c·∫ßn x√≥a');
      }
    }

    // H√†m m·ªõi ƒë·ªÉ x·ª≠ l√Ω bulk update cho vi·ªác x√≥a
    async function processBulkClearUpdate(batchUpdates, clearCount) {
      // // console.log('üì° Sending bulk clear update to API');
      try {
        const response = await fetch(UPDATE_BULK_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(batchUpdates)
        });

        const result = await response.json();

        if (!response.ok || !result.success) {
          throw new Error(result.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ server');
        }

        // flush queue and reload
        try {
          await fetch(`${mainHost}/sync/flush-queue`, { method: 'POST' });
        } catch (e) { }

        showTempMessage(`ƒê√£ x√≥a th√†nh c√¥ng ${clearCount} √¥.`);
        loadData(currentPage, true, true);

        // X√≥a kh·ªèi pending changes n·∫øu th√†nh c√¥ng
        batchUpdates.forEach(update => {
          removePendingChange(update["M√£ ƒë∆°n h√†ng"]);
        });

      } catch (error) {
        // console.error("‚ùå L·ªói khi x√≥a h√†ng lo·∫°t:", error);
        showTempMessage(`ƒê√£ x√≥a ${clearCount} √¥ nh∆∞ng c√≥ l·ªói khi l∆∞u. ƒê√£ l∆∞u thay ƒë·ªïi t·∫°m th·ªùi.`, true);

        // L∆∞u v√†o pending changes n·∫øu th·∫•t b·∫°i
        batchUpdates.forEach(update => {
          const primaryKey = update["M√£ ƒë∆°n h√†ng"];
          Object.entries(update).forEach(([field, value]) => {
            if (field !== "M√£ ƒë∆°n h√†ng") {
              savePendingChange(primaryKey, field, value);
            }
          });
        });
      }
    }

    function updateCellValue(cell, value) {
      // // console.log('üîß updateCellValue() called');
      // // console.log('Cell:', cell);
      // // console.log('Value to set:', value);
      // // console.log('Cell classList:', cell?.classList?.toString());

      if (!cell || !cell.classList.contains("editable")) {
        // console.log('‚ùå Cell is not editable or null');
        return false;
      }

      const select = cell.querySelector("select");
      const dateInput = cell.querySelector("input.date-input");
      let changed = false;

      // // console.log('Select element found:', !!select);
      // // console.log('Date input found:', !!dateInput);

      if (select) {
        // // console.log('Current select value:', select.value);
        // // console.log('New value:', value);
        // üî• FIX: Cho ph√©p x√≥a dropdown b·∫±ng c√°ch set value = ""
        if (select.value !== value) {
          select.value = value; // value c√≥ th·ªÉ l√† "" ƒë·ªÉ x√≥a
          // // console.log('‚úÖ Select value changed to:', select.value);
          select.dispatchEvent(new Event("change", {
            bubbles: true
          })); // K√≠ch ho·∫°t s·ª± ki·ªán change ƒë·ªÉ logic trong renderTableBody ch·∫°y
          changed = true;
        } else {
          // // console.log('‚ÑπÔ∏è Select value unchanged');
        }
      } else if (dateInput) {
        // // console.log('üìÖ Processing date input');
        // Logic for date input if any
      } else if (cell.textContent !== value) {
        // // console.log('üìù Processing text cell');
        // // console.log('Current text:', cell.textContent);
        // // console.log('New value:', value);
        cell.textContent = value;
        cell.classList.add("highlight");
        // // console.log('‚úÖ Text cell updated');
        changed = true;
        const tr = cell.closest("tr");
        const config = allTabConfigs.find(c => c.table.body === cell.closest("tbody").id);
        const rowIndex = parseInt(tr.dataset.rowIndex);
        const colName = displayColumns[cell.cellIndex];

        // üî• FIX: L·∫•y primaryKey tr·ª±c ti·∫øp t·ª´ DOM thay v√¨ d·ª±a v√†o rowIndex
        const primaryKey = getOrderCodeFromCell(cell);
        // // console.log('üîë Primary key from DOM:', primaryKey);

        if (primaryKey && primaryKey !== 'N/A' && primaryKey !== 'ERROR') {
          // === START: CODE ƒê√É S·ª¨A L·ªñI ===
          // C·∫≠p nh·∫≠t gi√° tr·ªã m·ªõi (r·ªóng) v√†o m·∫£ng d·ªØ li·ªáu JavaScript
          if (config && !isNaN(rowIndex)) {
            const dataArray = config.data();
            if (dataArray && dataArray[rowIndex]) {
              // // console.log('üìä Updating data array at index:', rowIndex);
              dataArray[rowIndex][colName] = value; // value ·ªü ƒë√¢y l√† ""

              if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                const timestamp = getDateTimeVN();
                dataArray[rowIndex]["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
              }
            } else {
              // console.log('‚ö†Ô∏è DataArray or rowIndex invalid:', { dataArray: !!dataArray, rowIndex });
            }
          } else {
            // console.log('‚ö†Ô∏è Config or rowIndex invalid:', { config: !!config, rowIndex });
          }
          // === END: CODE ƒê√É S·ª¨A L·ªñI ===

          // Chu·∫©n b·ªã API update
          const updates = {
            [colName]: value
          };
          if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
            const timestamp = getDateTimeVN();
            updates["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
            const dateColIndex = displayColumns.indexOf("Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2");
            if (dateColIndex > -1 && tr.cells[dateColIndex]) {
              tr.cells[dateColIndex].textContent = timestamp;
              tr.cells[dateColIndex].classList.add('highlight');
            }
          }

          // // console.log('üì° Sending API update:', { primaryKey, updates });
          processCellUpdate(primaryKey, updates);
        } else {
          // console.log('‚ùå Invalid primary key, skipping API update');
        }
        changed = true;
      } else {
        // console.log('‚ÑπÔ∏è No change needed for this cell type');
      }

      // // console.log('üîß updateCellValue result:', changed);
      return changed;
    }

    function showTempMessage(e, t = !1) { document.querySelector(".temp-message")?.remove(); const n = document.createElement("div"); n.textContent = e, Object.assign(n.style, { position: "fixed", bottom: "20px", right: "20px", backgroundColor: t ? "rgba(220, 53, 69, 0.9)" : "rgba(40, 167, 69, 0.9)", color: "white", padding: "12px 20px", borderRadius: "5px", zIndex: "2000", transition: "opacity 0.5s", opacity: "1", boxShadow: "0 4px 10px rgba(0,0,0,0.2)" }), document.body.appendChild(n), setTimeout(() => { n.style.opacity = "0", setTimeout(() => n.remove(), 500) }, 3e3) }

    async function handleData(response) {
      document.getElementById('loader-overlay').style.display = 'none';
      allTabConfigs.forEach(config => { document.getElementById(config.controls.refreshBtn).innerHTML = '<span class="refresh-icon">‚Üª</span> Load' });
      allData = [], staffFilteredData = [], japanData = [], leaderData = [], mentionedData = [], hcmData = [], hanoiData = [];
      // clearPendingChanges(); // MODIFIED: Do not clear changes on load to persist them

      if (response.error || !Array.isArray(response.rows)) {
        const errorMsg = 'L·ªói ho·∫∑c kh√¥ng c√≥ d·ªØ li·ªáu: ' + (response.error || 'ƒê·ªãnh d·∫°ng d·ªØ li·ªáu kh√¥ng ƒë√∫ng');
        allTabConfigs.forEach(config => showError(errorMsg, config.table.body));
        return;
      }
      allData = response.rows.sort((a, b) => (parseDateString(b["Ng√†y l√™n ƒë∆°n"] || b["Th·ªùi gian l√™n ƒë∆°n"]) || 0) - (parseDateString(a["Ng√†y l√™n ƒë∆°n"] || a["Th·ªùi gian l√™n ƒë∆°n"]) || 0));
      generateDatalistOptions();
      let staffId = getUrlParameter('id');

      // Dynamic Default: Select first available staff if ID is missing OR INVALID (not found in list)
      const isValidStaff = staffId && allStaffData.some(staff => String(staff.idnv) === String(staffId));

      if ((!staffId || !isValidStaff) && allStaffData && allStaffData.length > 0) {
        staffId = allStaffData[0].idnv;

        // Update URL to reflect the valid auto-selected ID
        const newUrl = new URL(window.location);
        newUrl.searchParams.set('id', staffId);
        window.history.replaceState({}, '', newUrl);
      }

      const mentionedStaffIds = (getUrlParameter('id1') || '').split(',').filter(id => id.trim() !== '');
      if (!staffId) {
        // üî• FIX: Render t·∫•t c·∫£ data khi kh√¥ng c√≥ staff ID thay v√¨ ch·ªâ hi·ªán error
        // // console.warn('Kh√¥ng t√¨m th·∫•y staff ID, hi·ªÉn th·ªã t·∫•t c·∫£ d·ªØ li·ªáu');
        document.getElementById('userInfo').textContent = 'Nh√¢n vi√™n: (Kh√¥ng x√°c ƒë·ªãnh)';
        staffFilteredData = allData;
        initializeTab(mainTabConfig, staffFilteredData);
      } else {
        try {
          currentStaff = await fetchStaffInfo(staffId);
          let staffInfo = `Nh√¢n vi√™n: ${currentStaff.ho_va_ten}`;
          if (currentStaff.vi_tri === "Leader" || currentStaff.vi_tri === "L√™n bill") staffInfo += ` (Leader - Team ${currentStaff.team})`;
          document.getElementById('userInfo').textContent = staffInfo;
          if (currentStaff.vi_tri_van_don === "L√™n ƒë∆°n FFM" && !editableCols.includes("ƒê∆°n v·ªã v·∫≠n chuy·ªÉn")) {
            editableCols.push("ƒê∆°n v·ªã v·∫≠n chuy·ªÉn");
          }
          if (currentStaff?.vi_tri === "Leader" || currentStaff?.vi_tri === "L√™n bill") {
            document.getElementById('tabLeader').style.display = '';
            leaderData = allData.filter(row => (row["NV V·∫≠n ƒë∆°n"] || row["NV_V·∫≠n_ƒë∆°n"]) === currentStaff.ho_va_ten);
            initializeTab(leaderTabConfig, leaderData);
          }
          if (currentStaff.vi_tri_van_don === "L√™n ƒë∆°n FFM") {
            const staffBranch = currentStaff.chi_nhanh;
            if (staffBranch === "HCM") {
              document.getElementById('tabHCM').style.display = '';
              hcmData = allData.filter(row => (row.Team || '') === 'HCM' && row["ƒê∆°n v·ªã v·∫≠n chuy·ªÉn"] == "" && row["K·∫øt qu·∫£ Check"] == "OK");
              initializeTab(hcmTabConfig, hcmData);
            } else if (staffBranch === "H√† N·ªôi") {
              document.getElementById('tabHanoi').style.display = '';
              hanoiData = allData.filter(row => (row.Team || '') === 'H√† N·ªôi' && row["ƒê∆°n v·ªã v·∫≠n chuy·ªÉn"] == "" && row["K·∫øt qu·∫£ Check"] == "OK");
              initializeTab(hanoiTabConfig, hanoiData);
            }
          }
          if (currentStaff?.vi_tri == 'Leader' || currentStaff?.vi_tri === "L√™n bill") {
            const staffBranch = currentStaff.chi_nhanh;
            if (staffBranch === "HCM") {
              document.getElementById('tabHCM').style.display = '';
              staffFilteredData = allData.filter(row => (row.Team || '') === 'HCM');
            } else if (staffBranch === "H√† N·ªôi") {
              document.getElementById('tabHanoi').style.display = '';
              staffFilteredData = allData.filter(row => (row.Team || '') === 'H√† N·ªôi');
            }
          } else {
            staffFilteredData = allData.filter(row => {
              return row["NV V·∫≠n ƒë∆°n"] === currentStaff.ho_va_ten
            });
          }

          // üî• FIX: Fallback - n·∫øu kh√¥ng c√≥ data sau filter th√¨ hi·ªÉn th·ªã t·∫•t c·∫£
          if (staffFilteredData.length === 0) {
            // // console.warn('‚ö†Ô∏è staffFilteredData r·ªóng, hi·ªÉn th·ªã t·∫•t c·∫£ allData');
            staffFilteredData = allData;
          }

          initializeTab(mainTabConfig, staffFilteredData);
        } catch (error) {
          showError(error.message, mainTabConfig.table.body);
        }
      }
      if (mentionedStaffIds.length > 0) {
        document.getElementById('tabMentioned').style.display = '';
        try {
          const mentionedStaffNames = await fetchMultipleStaffInfo(mentionedStaffIds);
          if (mentionedStaffNames.length > 0) {
            mentionedData = allData.filter(row => mentionedStaffNames.includes(row["NV V·∫≠n ƒë∆°n"] || row["NV_V·∫≠n_ƒë∆°n"]));
            initializeTab(mentionedTabConfig, mentionedData);
          } else {
            showError('Kh√¥ng t√¨m th·∫•y nh√¢n vi√™n n√†o cho c√°c ID ƒë∆∞·ª£c cung c·∫•p trong tham s·ªë id1.', 'mentionedTableBody');
          }
        } catch (error) { }
      }
      japanData = allData.filter(row => (row['khu v·ª±c'] || row['Khu v·ª±c']) === 'Nh·∫≠t B·∫£n');
      initializeTab(japanTabConfig, japanData);

      updateStatusButtonUI(); // MODIFIED: Update button state after data is handled
    }
    function initializeTab(config, data) { generateDynamicOptions(config, data); populateExternalFilters(config); renderHeader(config); renderTableBody(config, data); applyAllFilters(config); setupCellSelection(config.table.body); }
    function generateDynamicOptions(config, data) { const options = {}; columnsToMakeDynamic.forEach(colName => { if (dropdownCols[colName]) { options[colName] = dropdownCols[colName].filter(opt => opt !== "").sort((a, b) => String(a).localeCompare(String(b), 'vi')); } else { const dataKey = columnDisplayMapping[colName] || colName; const valueMapper = row => { const val = row[dataKey] || row[dataKey.replace(/ /g, '_')] || (dataKey === 'khu v·ª±c' ? row['Khu v·ª±c'] || '' : ''); return typeof val === 'string' ? val.trim() : val; }; const uniqueValues = new Set(data.map(valueMapper).filter(Boolean)); options[colName] = Array.from(uniqueValues).sort((a, b) => String(a).localeCompare(String(b), 'vi')); } }); if (config === mainTabConfig) dynamicFilterOptions = options; else if (config === japanTabConfig) japanDynamicFilterOptions = options; else if (config === leaderTabConfig) leaderDynamicFilterOptions = options; else if (config === mentionedTabConfig) mentionedDynamicFilterOptions = options; else if (config === hcmTabConfig) hcmDynamicFilterOptions = options; else if (config === hanoiTabConfig) hanoiDynamicFilterOptions = options; }
    function populateExternalFilters(config) { const options = config.dynamicOptions(); const productFilter = document.getElementById(config.controls.product); productFilter.innerHTML = '<option value="">T·∫•t c·∫£ s·∫£n ph·∫©m</option>'; (options['M·∫∑t h√†ng'] || []).forEach(opt => productFilter.add(new Option(opt, opt))); if (config.controls.market) { const marketFilter = document.getElementById(config.controls.market); marketFilter.innerHTML = '<option value="">T·∫•t c·∫£ khu v·ª±c</option>'; (options['khu v·ª±c'] || []).forEach(opt => marketFilter.add(new Option(opt, opt))) } if (config.controls.staff) { const staffFilter = document.getElementById(config.controls.staff); staffFilter.innerHTML = '<option value="">T·∫•t c·∫£ NV V·∫≠n ƒë∆°n</option>'; (options['NV V·∫≠n ƒë∆°n'] || []).forEach(opt => staffFilter.add(new Option(opt, opt))) } }
    function generateDatalistOptions() { datalistOptions = {}; datalistFilterCols.forEach(colName => { const dataKey = columnDisplayMapping[colName] || colName; const uniqueValues = new Set(allData.map(row => row[dataKey] || row[dataKey.replace(/ /g, '_')]).filter(Boolean)); datalistOptions[colName] = Array.from(uniqueValues) }) }
    function parseDateStringFilter(dateString) {
      const parts = dateString.split('/');
      // L∆∞u √Ω: th√°ng trong JavaScript b·∫Øt ƒë·∫ßu t·ª´ 0 (0 l√† th√°ng 1, 1 l√† th√°ng 2,...)
      // V√¨ v·∫≠y, ch√∫ng ta c·∫ßn tr·ª´ ƒëi 1 t·ª´ gi√° tr·ªã th√°ng.
      const day = parseInt(parts[0], 10);
      const month = parseInt(parts[1], 10) - 1;
      const year = parseInt(parts[2], 10);
      return new Date(year, month, day);
    }

    // =========================================================================
    // === H√ÄM ƒê∆Ø·ª¢C T·ªêI ∆ØU H√ìA - applyAllFilters ===
    // =========================================================================
    function applyAllFilters(config) {
      const tableHead = document.getElementById(config.table.head);
      const tableBody = document.getElementById(config.table.body);
      if (!tableHead.querySelector('tr') || !tableBody) return;

      // Thu th·∫≠p t·∫•t c·∫£ ƒëi·ªÅu ki·ªán l·ªçc
      const startDateVal = document.getElementById(config.controls.startDate).value;
      const endDateVal = document.getElementById(config.controls.endDate).value;
      const start = startDateVal ? new Date(startDateVal) : null;
      const end = endDateVal ? new Date(endDateVal) : null;
      if (start) start.setHours(0, 0, 0, 0);
      if (end) end.setHours(23, 59, 59, 999);

      const productValue = document.getElementById(config.controls.product).value;
      const marketValue = config.controls.market ? document.getElementById(config.controls.market).value : '';
      const staffValue = config.controls.staff ? document.getElementById(config.controls.staff).value : '';

      const filterValues = {};
      tableHead.querySelectorAll('[data-column]').forEach(filter => {
        const colName = filter.dataset.column;
        if (!filterValues[colName]) filterValues[colName] = {};
        if (filter.dataset.filterType) {
          filterValues[colName][filter.dataset.filterType] = filter.value.toLowerCase();
        } else if (filter.classList.contains('multi-select-container')) {
          const selected = Array.from(filter.querySelectorAll('input:checked:not(.select-all-cb)')).map(cb => cb.value);
          if (selected.length > 0) filterValues[colName].multi = new Set(selected);
        } else if (filter.tagName === 'SELECT') {
          if (filter.value) filterValues[colName].single = filter.value;
        } else if (filter.classList.contains('filter-input')) {
          filterValues[colName].text = filter.value.toLowerCase();
        }
      });

      // üî• THAY ƒê·ªîI CH√çNH: L·ªçc tr√™n d·ªØ li·ªáu g·ªëc thay v√¨ DOM
      const originalData = config.data();

      // L·ªçc d·ªØ li·ªáu g·ªëc
      const filteredData = originalData.filter((rowData, rowIndex) => {
        let isVisible = true;

        // L·ªçc theo ng√†y
        if (start || end) {
          const orderDate = parseDateStringFilter(rowData["Ng√†y l√™n ƒë∆°n"] || rowData["Th·ªùi gian l√™n ƒë∆°n"]);
          if (!orderDate || (start && orderDate < start) || (end && orderDate > end)) {
            isVisible = false;
          }
        }

        // L·ªçc theo s·∫£n ph·∫©m, khu v·ª±c, nh√¢n vi√™n
        if (isVisible && productValue && (rowData["M·∫∑t h√†ng"] || '') !== productValue) isVisible = false;
        if (isVisible && marketValue && (rowData["Khu v·ª±c"] || rowData["khu v·ª±c"] || '') !== marketValue) isVisible = false;
        if (isVisible && staffValue && (rowData["NV V·∫≠n ƒë∆°n"] || rowData["NV_V·∫≠n_ƒë∆°n"] || '') !== staffValue) isVisible = false;

        // L·ªçc theo c√°c c·ªôt kh√°c
        if (isVisible) {
          for (const colName in filterValues) {
            const dataKey = columnDisplayMapping[colName] || colName;
            let cellValue = rowData[dataKey] ?? (rowData[dataKey.replace(/ /g, '_')] || (dataKey === 'khu v·ª±c' ? (rowData['Khu v·ª±c'] || '') : ''));
            const cellValueLower = String(cellValue).toLowerCase();
            const colFilters = filterValues[colName];

            // L·ªçc theo tr·∫°ng th√°i (empty/not-empty/numeric-start)
            if (colFilters.state) {
              const valueString = String(cellValue).trim();
              const isBlank = !valueString;
              if (colFilters.state === 'empty') {
                if (!isBlank) {
                  isVisible = false;
                  break;
                }
              } else if (colFilters.state === 'not-empty') {
                if (isBlank) {
                  isVisible = false;
                  break;
                }
              } else if (colFilters.state === 'numeric-start') {
                if (isBlank || !/^\d/.test(valueString)) {
                  isVisible = false;
                  break;
                }
              }
            }

            // C√°c b·ªô l·ªçc kh√°c
            if (colFilters.text && !cellValueLower.includes(colFilters.text)) {
              isVisible = false;
              break;
            }
            if (colFilters.single && String(cellValue) !== colFilters.single) {
              isVisible = false;
              break;
            }
            if (colFilters.multi) {
              const valueAsString = String(cellValue).trim();
              const isBlank = !valueAsString;
              const isMatch = (colFilters.multi.has('') && isBlank) || colFilters.multi.has(valueAsString);
              if (!isMatch) {
                isVisible = false;
                break;
              }
            }
            if (colFilters.contains && !cellValueLower.includes(colFilters.contains)) {
              isVisible = false;
              break;
            }
            if (colFilters.notcontains && colFilters.notcontains !== '' && cellValueLower.includes(colFilters.notcontains)) {
              isVisible = false;
              break;
            }
          }
        }

        return isVisible;
      });

      // üî• RENDER L·∫†I B·∫¢NG v·ªõi d·ªØ li·ªáu ƒë√£ l·ªçc
      renderTableBody(config, filteredData);
      updateSummaryInfo(config);

      // üîß FIX: Clear selectedCells sau khi filter ƒë·ªÉ tr√°nh confusion
      // selectedCells.forEach(cell => cell.classList.remove("cell-selected"));
      // selectedCells.clear();
      // // console.log('üîÑ Cleared selectedCells after filter');

      // C·∫≠p nh·∫≠t sticky columns v√† cell selection
      setTimeout(() => {
        updateStickyColumns(config);
        setupCellSelection(config.table.body);
      }, 10);
    }

    // =========================================================================
    // === H√ÄM ƒê√É ƒê∆Ø·ª¢C CH·ªàNH S·ª¨A - renderHeader ===
    // =========================================================================
    function renderHeader(config) {
      const header = document.getElementById(config.table.head);
      const options = config.dynamicOptions();
      header.innerHTML = '';
      const tr = document.createElement('tr');
      const fixedCount = getFixedColumnCount();
      const debouncedFilter = () => { clearTimeout(filterDebounceTimer); filterDebounceTimer = setTimeout(() => applyAllFilters(config), 300) };
      const immediateFilter = () => applyAllFilters(config);
      displayColumns.forEach((colName, index) => {
        const th = document.createElement('th');
        th.textContent = colName;
        if (index < fixedCount) th.classList.add('fixed-column');
        th.appendChild(document.createElement('br'));

        if (colName === "M√£ Tracking") {
          const container = document.createElement('div');
          container.className = 'tracking-filter-container';

          const selectState = document.createElement('select');
          selectState.className = 'filter-select';
          selectState.style.marginBottom = '4px';
          selectState.dataset.column = colName;
          selectState.dataset.filterType = 'state';

          selectState.add(new Option('T√¨nh tr·∫°ng m√£', ''));
          selectState.add(new Option('T·∫•t c·∫£ c√≥ m√£', 'not-empty'));
          selectState.add(new Option('Tr·ªëng', 'empty'));
          // THAY ƒê·ªîI B·∫ÆT ƒê·∫¶U: Th√™m t√πy ch·ªçn "To√†n s·ªë"
          selectState.add(new Option('To√†n s·ªë', 'numeric-start'));
          // THAY ƒê·ªîI K·∫æT TH√öC
          selectState.addEventListener('change', immediateFilter);

          const inputContains = document.createElement('input');
          inputContains.type = 'text';
          inputContains.placeholder = 'Ch·ª©a k√Ω t·ª±...';
          inputContains.className = 'filter-input';
          inputContains.dataset.column = colName;
          inputContains.dataset.filterType = 'contains';
          inputContains.addEventListener('input', debouncedFilter);

          const inputNotContains = document.createElement('input');
          inputNotContains.type = 'text';
          inputNotContains.placeholder = 'Kh√¥ng ch·ª©a...';
          inputNotContains.className = 'filter-input';
          inputNotContains.dataset.column = colName;
          inputNotContains.dataset.filterType = 'notcontains';
          inputNotContains.addEventListener('input', debouncedFilter);

          container.append(selectState, inputContains, inputNotContains);
          th.appendChild(container);

        } else if (singleSelectFilterCols.includes(colName) && options[colName]) {
          const filterElement = document.createElement('select');
          filterElement.className = 'filter-select';
          filterElement.dataset.column = colName;
          filterElement.add(new Option(`T·∫•t c·∫£ ${colName}`, ''));
          options[colName].forEach(opt => filterElement.add(new Option(opt, opt)));
          filterElement.addEventListener('change', immediateFilter);
          th.appendChild(filterElement)
        } else if (options[colName]) {
          const container = document.createElement('div');
          container.className = 'multi-select-container';
          container.dataset.column = colName;
          const button = document.createElement('button');
          button.className = 'multi-select-button';
          button.textContent = `T·∫•t c·∫£ ${colName}`;
          const dropdown = document.createElement('div');
          dropdown.className = 'checkbox-dropdown';
          const selectAllLabel = document.createElement('label');
          const selectAllCheckbox = document.createElement('input');
          selectAllCheckbox.type = 'checkbox';
          selectAllCheckbox.className = 'select-all-cb';
          selectAllLabel.style.fontWeight = 'bold';
          selectAllLabel.style.borderBottom = '1px solid #ccc';
          selectAllLabel.style.marginBottom = '4px';
          selectAllLabel.append(selectAllCheckbox, ' (T·∫•t c·∫£)');
          dropdown.appendChild(selectAllLabel);
          const createCheckbox = (value, text) => {
            const label = document.createElement('label');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox'; checkbox.value = value;
            checkbox.addEventListener('change', () => {
              const allOptionCheckboxes = Array.from(dropdown.querySelectorAll('input[type="checkbox"]:not(.select-all-cb)'));
              selectAllCheckbox.checked = allOptionCheckboxes.every(cb => cb.checked);
              const selectedCount = dropdown.querySelectorAll('input:checked:not(.select-all-cb)').length;
              button.textContent = selectedCount === 0 ? `T·∫•t c·∫£ ${colName}` : `${selectedCount} l·ª±a ch·ªçn`; immediateFilter();
            });
            label.append(checkbox, ` ${text}`);
            return label;
          };
          dropdown.appendChild(createCheckbox('', '(Tr·ªëng)'));
          options[colName].forEach(opt => dropdown.appendChild(createCheckbox(opt, opt)));
          selectAllCheckbox.addEventListener('change', (e) => {
            dropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = e.target.checked);
            const selectedCount = e.target.checked ? dropdown.querySelectorAll('input:checked:not(.select-all-cb)').length : 0;
            button.textContent = selectedCount === 0 ? `T·∫•t c·∫£ ${colName}` : `${selectedCount} l·ª±a ch·ªçn`;
            immediateFilter();
          });
          button.addEventListener('click', e => {
            e.stopPropagation();
            // Close other dropdowns first
            document.querySelectorAll('.checkbox-dropdown.show').forEach(d => {
              if (d !== dropdown) d.classList.remove('show');
            });

            // Toggle this dropdown
            const isShowing = !dropdown.classList.contains('show');
            dropdown.classList.toggle('show');

            // Position dropdown with fixed positioning
            if (isShowing) {
              const rect = button.getBoundingClientRect();
              dropdown.style.top = (rect.bottom + 8) + 'px';
              dropdown.style.left = rect.left + 'px';
            }
          });
          container.append(button, dropdown);
          th.appendChild(container)
        } else if (datalistFilterCols.includes(colName)) {
          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'filter-input';
          input.placeholder = `L·ªçc ${colName}...`;
          input.dataset.column = colName;
          const datalistId = `datalist-${colName.replace(/[^a-zA-Z0-9]/g, '-')}`;
          input.setAttribute('list', datalistId);
          const datalist = document.createElement('datalist');
          datalist.id = datalistId;
          if (datalistOptions[colName]) {
            datalistOptions[colName].forEach(opt => {
              const option = document.createElement('option');
              option.value = opt; datalist.appendChild(option)
            })
          }
          input.addEventListener('input', debouncedFilter);
          th.append(input, datalist)
        } else {
          const filterElement = document.createElement('input');
          filterElement.type = 'text';
          filterElement.className = 'filter-input';
          filterElement.placeholder = `L·ªçc ${colName}...`;
          filterElement.dataset.column = colName;
          filterElement.addEventListener('input', debouncedFilter);
          th.appendChild(filterElement)
        }
        tr.appendChild(th)
      });
      header.appendChild(tr);
      window.addEventListener('click', e => {
        if (!e.target.closest('.multi-select-container')) {
          document.querySelectorAll('.checkbox-dropdown.show').forEach(d => d.classList.remove('show'))
        }
      })
    }

    // === OPTIMIZED: renderTableBody using DocumentFragment ===
    function renderTableBody(config, data) {
      const container = document.getElementById(config.table.body);
      container.innerHTML = '';

      if (data.length === 0) {
        showError(`Kh√¥ng c√≥ ƒë∆°n h√†ng n√†o.`, config.table.body);
        return;
      }

      const startTime = performance.now();
      const fixedCount = getFixedColumnCount();
      const fragment = document.createDocumentFragment();

      data.forEach((row, filteredIndex) => {
        const tr = document.createElement('tr');
        tr.dataset.filteredIndex = filteredIndex;
        tr.dataset.primaryKey = row["M√£ ƒë∆°n h√†ng"] || '';

        displayColumns.forEach((col, colIndex) => {
          const td = document.createElement('td');
          if (colIndex < fixedCount) td.classList.add('fixed-column');
          if (longTextColumns.includes(col)) td.classList.add('long-text-cell');

          const dataKey = columnDisplayMapping[col] || col;
          let value;

          // Date formatting
          if (allDateColumns.includes(dataKey)) {
            let dateSource = row[dataKey] || '';
            if (dataKey === "Ng√†y l√™n ƒë∆°n") dateSource = row["Ng√†y l√™n ƒë∆°n"] || row["Th·ªùi gian l√™n ƒë∆°n"];
            const formattedDate = formatDate(dateSource);
            value = formattedDate.display;
            td.dataset.originalValue = formattedDate.original;
          } else {
            value = row[dataKey] ?? '';
          }

          // Editable cells
          if (editableCols.includes(col)) {
            td.classList.add('editable');
            td.dataset.col = col;

            if (dropdownCols[col]) {
              td.classList.add('has-dropdown');
              const select = document.createElement('select');
              select.dataset.col = col;

              // Normalize value for comparison
              const normalizedValue = normalizeUnicode(value);

              // Build options efficiently
              const opts = dropdownCols[col];
              opts.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt;
                option.textContent = opt;
                // Compare normalized values
                if (normalizeUnicode(opt) === normalizedValue) option.selected = true;
                select.appendChild(option);
              });

              td.appendChild(select);
            } else {
              td.textContent = value;
            }
          } else {
            td.textContent = value;
          }

          // Status coloring (with normalized comparison)
          if (col === "K·∫øt qu·∫£ Check") {
            const nv = normalizeUnicode(value);
            if (nv === 'OK') td.classList.add('cell-ok');
            else if (nv === 'V·∫≠n ƒë∆°n XL') td.classList.add('cell-xl');
            else if (nv === 'Hu·ª∑' || nv === 'H·ªßy') td.classList.add('cell-cancel');
          }

          tr.appendChild(td);
        });

        fragment.appendChild(tr);
      });

      container.appendChild(fragment);

      // Event delegation for select changes (single listener for all)
      if (!container.dataset.delegated) {
        container.addEventListener('change', handleCellChangeEvent);
        container.dataset.delegated = 'true';
      }

      const endTime = performance.now();
      // console.log(`‚ö° Rendered ${data.length} rows in ${(endTime - startTime).toFixed(0)}ms`);

      updateStickyColumns(config);
    }

    // === Event delegation handler ===
    function handleCellChangeEvent(e) {
      if (e.target.tagName !== 'SELECT') return;

      const select = e.target;
      const td = select.closest('td');
      const tr = select.closest('tr');
      if (!td || !tr) return;

      const col = select.dataset.col;
      const primaryKey = tr.dataset.primaryKey;
      const newValue = select.value;

      if (!primaryKey || !col) return;

      td.classList.add('highlight');

      // Update local data
      const idx = allData.findIndex(item => item["M√£ ƒë∆°n h√†ng"] === primaryKey);
      if (idx !== -1) {
        allData[idx][col] = newValue;
      }

      // Send update to server
      processCellUpdate(primaryKey, { [col]: newValue });
    }
    function setupControls() {
      setupTabs();
      allTabConfigs.forEach(setupTabControls);
      document.getElementById('fixedColumnCountInput').addEventListener('input', handleFixedColumnCountChange);

      // MODIFIED: Add listeners for popover
      document.getElementById('statusButton').addEventListener('click', showStatusPopover);
      document.querySelector('.close-popover').addEventListener('click', hideStatusPopover);
      document.getElementById('status-popover').addEventListener('click', (e) => {
        if (e.target.id === 'status-popover') hideStatusPopover();
      });
      document.getElementById('update-all-pending').addEventListener('click', handleUpdateAllPending);
      document.getElementById('cancel-all-changes').addEventListener('click', handleCancelAllChanges);

      document.addEventListener('keydown', e => {
        const activeEl = document.activeElement;
        if (activeEl && ['INPUT', 'SELECT', 'TEXTAREA'].includes(activeEl.tagName) && !activeEl.closest('td')) return;
        if (document.querySelector('td.editing')) return;
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c' && selectedCells.size > 0) { e.preventDefault(); copySelectedCells() }
        else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'v' && selectedCells.size > 0) { e.preventDefault(); navigator.clipboard.readText().then(text => pasteToSelectedCells(text)).catch(err => { /* ignore clipboard error */ }) }
        else if ((e.key === 'Delete' || e.key === 'Backspace') && selectedCells.size > 0) {
          // // console.log('üóëÔ∏è Delete/Backspace key pressed'); 
          // // console.log('Selected cells size:', selectedCells.size);
          e.preventDefault();
          clearSelectedCells()
        }
        // === THAY TH·∫æ/TH√äM LOGIC CTRL+ENTER N√ÄY ===
        else if (e.key === 'Enter' && e.ctrlKey) {
          e.preventDefault();
          areLongTextFieldsExpanded = !areLongTextFieldsExpanded;
          toggleAllLongTextCells(areLongTextFieldsExpanded);
        }
        // === K·∫æT TH√öC ===
      });

      window.addEventListener('resize', () => {
        const activeTab = document.querySelector('.content-tab.active'); if (!activeTab) return;
        const activeConfig = allTabConfigs.find(c => c.table.body === activeTab.querySelector('tbody')?.id);
        if (activeConfig) updateStickyColumns(activeConfig)
      });
    }
    function setupTabControls(config) { document.getElementById(config.controls.refreshBtn).addEventListener('click', refreshData); document.getElementById(config.controls.updateBtn).addEventListener('click', () => processBulkUpdate(config)); const filterFunction = () => applyAllFilters(config); document.getElementById(config.controls.startDate).addEventListener('change', filterFunction); document.getElementById(config.controls.endDate).addEventListener('change', filterFunction); document.getElementById(config.controls.product).addEventListener('change', filterFunction); if (config.controls.market) document.getElementById(config.controls.market).addEventListener('change', filterFunction); if (config.controls.staff) document.getElementById(config.controls.staff).addEventListener('change', filterFunction); document.getElementById(config.controls.clearBtn).addEventListener('click', () => { document.getElementById(config.controls.startDate).value = ''; document.getElementById(config.controls.endDate).value = ''; document.getElementById(config.controls.product).selectedIndex = 0; if (config.controls.market) document.getElementById(config.controls.market).selectedIndex = 0; if (config.controls.staff) document.getElementById(config.controls.staff).selectedIndex = 0; const header = document.getElementById(config.table.head); header.querySelectorAll('.filter-input').forEach(f => f.value = ''); header.querySelectorAll('.filter-select').forEach(f => f.selectedIndex = 0); header.querySelectorAll('.multi-select-container').forEach(container => { container.querySelectorAll('input:checked').forEach(cb => cb.checked = !1); container.querySelector('.multi-select-button').textContent = `T·∫•t c·∫£ ${container.dataset.column}` }); applyAllFilters(config) }) }
    function refreshData() { loadData() }
    function setupTabs() {
      const tabs = document.querySelectorAll('.tab-btn'),
        contents = document.querySelectorAll('.content-tab');
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          selectedCells.forEach(cell => cell.classList.remove('cell-selected'));
          selectedCells.clear();
          isMouseDown = !1;
          startCell = null;
          tabs.forEach(item => item.classList.remove('active'));
          contents.forEach(content => content.classList.remove('active'));
          tab.classList.add('active');
          const contentId = 'content' + tab.id.substring(3);
          document.getElementById(contentId).classList.add('active');
          setTimeout(() => {
            handleFixedColumnCountChange();
            const summaryEl = document.getElementById('selectionSummary');
            if (summaryEl) summaryEl.innerHTML = contentId === 'contentData' ? '' : '';
          }, 10)
          refreshData()
        })
      })
    }


    async function processBulkUpdate(config) {
      const pendingChanges = getPendingChanges();
      const payload = Object.values(pendingChanges);

      if (payload.length === 0) {
        showTempMessage('Kh√¥ng c√≥ thay ƒë·ªïi n√†o trong kho ƒë·ªÉ c·∫≠p nh·∫≠t.', true);
        return;
      }

      const updateBtn = document.getElementById(config.controls.updateBtn);
      updateBtn.disabled = true;
      updateBtn.textContent = 'ƒêang x·ª≠ l√Ω...';

      try {
        const response = await fetch(UPDATE_BULK_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const result = await response.json();

        if (!response.ok || !result.success) {
          throw new Error(result.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ server');
        }

        showTempMessage(`C·∫≠p nh·∫≠t h√†ng lo·∫°t th√†nh c√¥ng ${result.summary.queued} ƒë∆°n h√†ng. ƒêang ƒë·ªìng b·ªô...`);
        clearPendingChanges();

        // Flush queue ƒë·ªÉ ƒë·∫£m b·∫£o DB ƒë∆∞·ª£c c·∫≠p nh·∫≠t tr∆∞·ªõc khi reload data
        try {
          await fetch(`${mainHost}/sync/flush-queue`, { method: 'POST' });
        } catch (e) { /* ignore flush errors */ }

        loadData(currentPage, true, true);
      } catch (error) {
        // console.error("L·ªói khi c·∫≠p nh·∫≠t h√†ng lo·∫°t:", error);
        showTempMessage(`L·ªói c·∫≠p nh·∫≠t. Vui l√≤ng li√™n h·ªá l·∫≠p tr√¨nh vi√™n.`, true);
      } finally {
        updateBtn.disabled = false;
        updateBtn.textContent = 'C·∫≠p nh·∫≠t';
      }
    }

    // === NEW: Load data from PostgreSQL with CACHE + PREFETCH ===
    async function loadData(page = 1, showLoader = true, forceRefresh = false) {
      currentPage = page;

      // Check cache first
      if (!forceRefresh) {
        const cached = pageCache.get(page);
        const now = Date.now();
        if (cached && (now - cached.timestamp) < CACHE_TTL_MS) {
          displayPageData(cached.data, cached.meta);
          prefetchNextPage(page + 1); // Prefetch next
          return;
        }
      } else {
        pageCache.clear(); // Clear local cache on force refresh
      }

      // Show loader only if not cached
      if (showLoader) {
        document.getElementById('loader-overlay').style.display = 'flex';
      }

      try {
        // Fetch staff data once
        await fetchAllStaffData();

        // Fetch from DB - add timestamp if forceRefresh to bypass Edge cache
        const url = `${DB_DATA_URL}?page=${page}&limit=${pageSize}&sortBy=id&order=asc${forceRefresh ? '&_t=' + Date.now() : ''}`;

        const response = await fetch(url);
        const json = await response.json();

        if (!json.success) {
          throw new Error(json.message || 'Failed to fetch data');
        }

        const data = json.data || [];
        const meta = {
          total: json.meta?.total || data.length,
          totalPages: json.meta?.totalPages || 1
        };

        // Save to cache
        pageCache.set(page, { data, meta, timestamp: Date.now() });
        // console.log(`‚úÖ Page ${page} loaded & cached (${data.length} rows)`);

        // Display
        displayPageData(data, meta);

        // Prefetch next page in background
        prefetchNextPage(page + 1);

      } catch (error) {
        // console.error('Error loading data:', error);
        allTabConfigs.forEach(config => showError('L·ªói: ' + error.message, config.table.body));
      } finally {
        document.getElementById('loader-overlay').style.display = 'none';
      }
    }

    // === Display page data ===
    function displayPageData(data, meta) {
      totalRecords = meta.total;
      totalPages = meta.totalPages;

      // Update cached summary from current page data
      cachedVisibleCount = data.length;
      cachedTotalAmount = 0;
      data.forEach(row => {
        let amountValue = row["T·ªïng ti·ªÅn VNƒê"] || row["T·ªïng_ti·ªÅn_VNƒê"] ||
          row["T·ªïng ti·ªÅn VND"] || row["Gi√° b√°n"] || 0;
        cachedTotalAmount += parseFloat(String(amountValue).replace(/[^\d.-]/g, "")) || 0;
      });

      handleData({ rows: data });
      updatePaginationUI();

      if (allData && allData.length > 0) {
        renderTableBody(allTabConfigs[0], allData);
      }
    }

    // === Prefetch next page in background ===
    async function prefetchNextPage(page) {
      if (page > totalPages || page < 1 || isPrefetching) return;
      if (pageCache.has(page)) return; // Already cached

      isPrefetching = true;
      try {
        const url = `${DB_DATA_URL}?page=${page}&limit=${pageSize}&sortBy=id&order=asc`;
        // console.log(`üîÆ Prefetching page ${page}...`);

        const response = await fetch(url);
        const json = await response.json();

        if (json.success) {
          const data = json.data || [];
          const meta = {
            total: json.meta?.total || data.length,
            totalPages: json.meta?.totalPages || 1
          };
          pageCache.set(page, { data, meta, timestamp: Date.now() });
          // console.log(`‚úÖ Prefetched page ${page} (${data.length} rows)`);
        }
      } catch (err) {
        // // console.warn('Prefetch failed:', err.message);
      } finally {
        isPrefetching = false;
      }
    }

    // === Pagination UI Update (Minimalist with Summary) ===
    let cachedVisibleCount = 0;
    let cachedTotalAmount = 0;

    function updatePaginationUI() {
      const paginationEl = document.getElementById('paginationInfo');
      if (!paginationEl) return;

      const formattedAmount = new Intl.NumberFormat("vi-VN").format(cachedTotalAmount);

      // Always show, even for 1 page (to display summary)
      paginationEl.style.display = 'flex';

      const paginationButtons = totalPages > 1 ? `
        <button class="pg-btn" onclick="goToPage(1)" ${currentPage <= 1 ? 'disabled' : ''}>¬´</button>
        <button class="pg-btn" onclick="goToPage(${currentPage - 1})" ${currentPage <= 1 ? 'disabled' : ''}>‚Äπ</button>
        <span class="pg-info">${currentPage} / ${totalPages}</span>
        <button class="pg-btn" onclick="goToPage(${currentPage + 1})" ${currentPage >= totalPages ? 'disabled' : ''}>‚Ä∫</button>
        <button class="pg-btn" onclick="goToPage(${totalPages})" ${currentPage >= totalPages ? 'disabled' : ''}>¬ª</button>
        <span class="pg-divider"></span>
      ` : '';

      paginationEl.innerHTML = `
        ${paginationButtons}
        <span class="pg-stat"><b>${cachedVisibleCount}</b> ƒë∆°n</span>
        <span class="pg-stat pg-amount"><b>${formattedAmount}</b> ƒë</span>
      `;
    }

    // Called after rendering to update visible count/amount
    function updateCachedSummary(visibleCount, totalAmount) {
      cachedVisibleCount = visibleCount;
      cachedTotalAmount = totalAmount;
      updatePaginationUI();
    }

    // === Go to specific page ===
    function goToPage(page) {
      if (page < 1 || page > totalPages || page === currentPage) return;
      loadData(page, false); // Don't show loader if cached
    }

    document.addEventListener('DOMContentLoaded', () => {
      setupControls();
      loadData().then(() => {
        // Skip SSE on Vercel, use polling directly (3-second interval)
        // console.log('üîÑ Starting real-time polling sync...');
        startPollingFallback();
      });

      // Pause polling when tab is hidden, resume when visible
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          stopPollingFallback();
        } else {
          startPollingFallback();
        }
      });

      // Auto refresh page every 30 minutes
      const AUTO_REFRESH_INTERVAL = 30 * 60 * 1000; // 30 minutes
      setInterval(() => {
        // console.log('üîÑ Auto-refreshing page (30 minute interval)...');
        window.location.reload();
      }, AUTO_REFRESH_INTERVAL);
    });
  </script>
</body>

</html>